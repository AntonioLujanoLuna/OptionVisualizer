// Python Files Concatenated on 01/27/2025 19:09:25
// ----------------------------------------



// File: C:\Users\aluja\Desktop\OptionVisualizer\app.py
// ----------------------------------------
0001: # src/app.py
0002: import streamlit as st
0003: from .src.ui.option_visualizer import OptionVisualizerApp
0004: 
0005: def main():
0006:     app = OptionVisualizerApp()
0007:     app.run()
0008: 
0009: if __name__ == "__main__":
0010:     main()

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\__init__.py
// ----------------------------------------

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\analytics\__init__.py
// ----------------------------------------

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\analytics\portfolio_visualization.py
// ----------------------------------------
0001: # src/analytics/portfolio_visualization.py
0002: 
0003: import numpy as np
0004: import plotly.graph_objects as go
0005: from plotly.subplots import make_subplots
0006: from typing import Dict, List, Optional
0007: from dataclasses import dataclass
0008: 
0009: from .risk import Position, RiskMetrics
0010: from src.config import AppConfig
0011: 
0012: class PortfolioVisualizer:
0013:     """
0014:     Creates interactive visualizations for portfolio analysis and risk management.
0015:     
0016:     This class provides visualizations that help users understand:
0017:     1. Portfolio composition and risk exposures
0018:     2. Scenario analysis results
0019:     3. Profit/Loss profiles under different market conditions
0020:     4. Risk metrics and their evolution over time
0021:     """
0022:     
0023:     def __init__(self, config: Optional[VisualizationConfig] = None):
0024:         """Initialize with optional custom visualization configuration."""
0025:         self.config = config or VisualizationConfig()
0026:     
0027:     def plot_portfolio_composition(self, positions: List[Position]) -> go.Figure:
0028:         """
0029:         Create an interactive visualization of portfolio composition.
0030:         
0031:         This visualization shows:
0032:         1. Distribution of positions by option type and expiry
0033:         2. Position sizes and directions (long/short)
0034:         3. Strike price distribution
0035:         4. Exposure to different underlyings
0036:         """
0037:         fig = go.Figure()
0038:         
0039:         # Group positions by option type
0040:         calls = [p for p in positions if p.option_type.lower() == 'call']
0041:         puts = [p for p in positions if p.option_type.lower() == 'put']
0042:         
0043:         # Create bubble chart for calls
0044:         if calls:
0045:             fig.add_trace(go.Scatter(
0046:                 x=[p.strike for p in calls],
0047:                 y=[p.expiry for p in calls],
0048:                 mode='markers',
0049:                 name='Calls',
0050:                 marker=dict(
0051:                     size=[abs(p.quantity) * 10 for p in calls],
0052:                     color=['green' if p.quantity > 0 else 'red' for p in calls],
0053:                     symbol='circle',
0054:                     line=dict(color='black', width=1)
0055:                 ),
0056:                 text=[f"Qty: {p.quantity}<br>Strike: {p.strike}" for p in calls],
0057:                 hoverinfo='text'
0058:             ))
0059:         
0060:         # Create bubble chart for puts
0061:         if puts:
0062:             fig.add_trace(go.Scatter(
0063:                 x=[p.strike for p in puts],
0064:                 y=[p.expiry for p in puts],
0065:                 mode='markers',
0066:                 name='Puts',
0067:                 marker=dict(
0068:                     size=[abs(p.quantity) * 10 for p in puts],
0069:                     color=['green' if p.quantity > 0 else 'red' for p in puts],
0070:                     symbol='square',
0071:                     line=dict(color='black', width=1)
0072:                 ),
0073:                 text=[f"Qty: {p.quantity}<br>Strike: {p.strike}" for p in puts],
0074:                 hoverinfo='text'
0075:             ))
0076:         
0077:         # Add vertical line at current underlying price
0078:         current_price = positions[0].underlying_price if positions else 0
0079:         fig.add_vline(
0080:             x=current_price,
0081:             line_dash="dash",
0082:             line_color="gray",
0083:             annotation_text="Current Price"
0084:         )
0085:         
0086:         fig.update_layout(
0087:             title='Portfolio Position Analysis',
0088:             xaxis_title='Strike Price',
0089:             yaxis_title='Time to Expiry (Years)',
0090:             showlegend=True,
0091:             width=self.config.width,
0092:             height=self.config.height,
0093:             template=self.config.template,
0094:             annotations=[
0095:                 dict(
0096:                     text="Green: Long positions<br>Red: Short positions<br>Size: Position quantity",
0097:                     xref="paper", yref="paper",
0098:                     x=1.02, y=0.98,
0099:                     showarrow=False,
0100:                     align='left'
0101:                 )
0102:             ]
0103:         )
0104: 
0105:     def plot_risk_profile(self, positions: List[Position],
0106:                          price_range: Optional[Tuple[float, float]] = None) -> go.Figure:
0107:         """
0108:         Create an interactive visualization of the portfolio's risk profile.
0109:         
0110:         This method generates a comprehensive view of how the portfolio value
0111:         changes with the underlying price. It helps traders understand their
0112:         risk exposure and identify potential hedging needs by showing:
0113:         
0114:         1. Total portfolio P&L across different price levels
0115:         2. Contribution of individual positions to overall risk
0116:         3. Key price points where risk characteristics change
0117:         4. Maximum profit and loss scenarios
0118:         """
0119:         if not positions:
0120:             raise ValueError("Cannot create risk profile for empty portfolio")
0121:         
0122:         # Determine price range if not provided
0123:         if price_range is None:
0124:             current_price = positions[0].underlying_price
0125:             price_range = (current_price * 0.7, current_price * 1.3)
0126:         
0127:         # Generate price points for x-axis
0128:         prices = np.linspace(price_range[0], price_range[1], 100)
0129:         
0130:         # Create figure with secondary y-axis for Greeks
0131:         fig = make_subplots(specs=[[{"secondary_y": True}]])
0132:         
0133:         # Calculate portfolio value at each price point
0134:         total_values = np.zeros_like(prices)
0135:         
0136:         # Plot individual position contributions
0137:         for position in positions:
0138:             position_values = self._calculate_position_values(position, prices)
0139:             
0140:             # Add trace for this position
0141:             fig.add_trace(
0142:                 go.Scatter(
0143:                     x=prices,
0144:                     y=position_values,
0145:                     name=f"{position.option_type.title()} K={position.strike:.1f} T={position.expiry:.2f}",
0146:                     line=dict(dash='dash'),
0147:                     opacity=0.6
0148:                 ),
0149:                 secondary_y=False
0150:             )
0151:             
0152:             total_values += position_values
0153:         
0154:         # Add total portfolio value
0155:         fig.add_trace(
0156:             go.Scatter(
0157:                 x=prices,
0158:                 y=total_values,
0159:                 name="Total Portfolio",
0160:                 line=dict(color='black', width=3)
0161:             ),
0162:             secondary_y=False
0163:         )
0164:         
0165:         # Add portfolio delta on secondary axis
0166:         deltas = np.gradient(total_values, prices)
0167:         fig.add_trace(
0168:             go.Scatter(
0169:                 x=prices,
0170:                 y=deltas,
0171:                 name="Portfolio Delta",
0172:                 line=dict(color='red', dash='dot'),
0173:             ),
0174:             secondary_y=True
0175:         )
0176:         
0177:         # Add key reference lines and annotations
0178:         current_price = positions[0].underlying_price
0179:         fig.add_vline(
0180:             x=current_price,
0181:             line_dash="dash",
0182:             line_color="gray",
0183:             annotation_text="Current Price"
0184:         )
0185:         
0186:         # Add break-even points
0187:         break_even_points = self._find_break_even_points(prices, total_values)
0188:         for point in break_even_points:
0189:             fig.add_vline(
0190:                 x=point,
0191:                 line_dash="dot",
0192:                 line_color="green",
0193:                 annotation_text="Break Even"
0194:             )
0195:         
0196:         fig.update_layout(
0197:             title='Portfolio Risk Profile',
0198:             xaxis_title='Underlying Price',
0199:             yaxis_title='Profit/Loss',
0200:             yaxis2_title='Portfolio Delta',
0201:             width=self.config.width,
0202:             height=self.config.height,
0203:             template=self.config.template,
0204:             hovermode='x unified',
0205:             annotations=[
0206:                 dict(
0207:                     text=f"Max Profit: ${np.max(total_values):,.2f}<br>"
0208:                          f"Max Loss: ${np.min(total_values):,.2f}",
0209:                     xref="paper", yref="paper",
0210:                     x=1.02, y=0.98,
0211:                     showarrow=False,
0212:                     align='left'
0213:                 )
0214:             ]
0215:         )
0216:         
0217:         return fig
0218:     
0219:     def plot_greek_exposures(self, positions: List[Position],
0220:                            risk_metrics: RiskMetrics) -> go.Figure:
0221:         """
0222:         Create a comprehensive visualization of portfolio Greek exposures.
0223:         
0224:         This visualization helps risk managers understand their exposure to
0225:         various market factors through multiple complementary views:
0226:         
0227:         1. A radar chart showing relative Greek exposures
0228:         2. Bar charts showing contribution by position
0229:         3. Time decay visualization
0230:         4. Volatility exposure analysis
0231:         """
0232:         # Create four subplots: radar chart and three bar charts
0233:         fig = make_subplots(
0234:             rows=2, cols=2,
0235:             specs=[
0236:                 [{"type": "polar"}, {"type": "xy"}],
0237:                 [{"type": "xy"}, {"type": "xy"}]
0238:             ],
0239:             subplot_titles=[
0240:                 "Greek Exposures Overview",
0241:                 "Delta Contribution by Position",
0242:                 "Gamma Profile",
0243:                 "Theta Decay"
0244:             ]
0245:         )
0246:         
0247:         # Radar chart of normalized Greeks
0248:         greeks = {
0249:             'Delta': risk_metrics.delta_exposure,
0250:             'Gamma': risk_metrics.gamma_exposure,
0251:             'Theta': risk_metrics.theta_exposure,
0252:             'Vega': risk_metrics.vega_exposure
0253:         }
0254:         
0255:         # Normalize Greeks for radar chart
0256:         max_values = {k: max(abs(v), 0.0001) for k, v in greeks.items()}
0257:         normalized_greeks = {k: v/max_values[k] for k, v in greeks.items()}
0258:         
0259:         fig.add_trace(
0260:             go.Scatterpolar(
0261:                 r=list(normalized_greeks.values()),
0262:                 theta=list(normalized_greeks.keys()),
0263:                 fill='toself',
0264:                 name='Normalized Exposure'
0265:             ),
0266:             row=1, col=1
0267:         )
0268:         
0269:         # Bar chart of delta contributions
0270:         position_deltas = self._calculate_position_greeks(positions)
0271:         fig.add_trace(
0272:             go.Bar(
0273:                 x=[f"Pos {i+1}" for i in range(len(positions))],
0274:                 y=[d['delta'] for d in position_deltas],
0275:                 name='Delta Exposure'
0276:             ),
0277:             row=1, col=2
0278:         )
0279:         
0280:         # Gamma profile
0281:         current_price = positions[0].underlying_price
0282:         price_range = np.linspace(current_price * 0.8, current_price * 1.2, 50)
0283:         gamma_profile = self._calculate_gamma_profile(positions, price_range)
0284:         
0285:         fig.add_trace(
0286:             go.Scatter(
0287:                 x=price_range,
0288:                 y=gamma_profile,
0289:                 name='Gamma Profile'
0290:             ),
0291:             row=2, col=1
0292:         )
0293:         
0294:         # Theta decay
0295:         days_to_expiry = np.linspace(0, 30, 31)  # Next 30 days
0296:         theta_decay = self._calculate_theta_decay(positions, days_to_expiry)
0297:         
0298:         fig.add_trace(
0299:             go.Scatter(
0300:                 x=days_to_expiry,
0301:                 y=theta_decay,
0302:                 name='Theta Decay'
0303:             ),
0304:             row=2, col=2
0305:         )
0306:         
0307:         # Update layout with educational annotations
0308:         fig.update_layout(
0309:             height=800,
0310:             width=self.config.width,
0311:             template=self.config.template,
0312:             showlegend=True,
0313:             annotations=[
0314:                 dict(
0315:                     text="Larger area indicates higher sensitivity",
0316:                     xref="paper", yref="paper",
0317:                     x=0.02, y=0.98,
0318:                     showarrow=False
0319:                 ),
0320:                 dict(
0321:                     text="Negative theta indicates time decay cost",
0322:                     xref="paper", yref="paper",
0323:                     x=0.98, y=0.02,
0324:                     showarrow=False
0325:                 )
0326:             ]
0327:         )
0328:         
0329:         return fig
0330:     
0331:     def plot_stress_test_results(self, risk_metrics: RiskMetrics) -> go.Figure:
0332:         """
0333:         Create a visualization of stress test results.
0334:         
0335:         This visualization helps users understand how their portfolio might
0336:         perform under various market stress scenarios. It includes:
0337:         
0338:         1. Waterfall chart showing impact of each scenario
0339:         2. Heat map of scenario correlations
0340:         3. Distribution of stress test outcomes
0341:         4. Comparison to VaR and expected shortfall
0342:         """
0343:         scenarios = risk_metrics.stress_scenarios
0344:         if not scenarios:
0345:             raise ValueError("No stress test results available")
0346:         
0347:         # Create figure with two subplots
0348:         fig = make_subplots(
0349:             rows=2, cols=1,
0350:             subplot_titles=[
0351:                 "Stress Test Impacts",
0352:                 "Scenario Outcome Distribution"
0353:             ],
0354:             vertical_spacing=0.2
0355:         )
0356:         
0357:         # Sort scenarios by impact
0358:         sorted_scenarios = sorted(
0359:             scenarios.items(),
0360:             key=lambda x: abs(x[1]),
0361:             reverse=True
0362:         )
0363:         
0364:         # Waterfall chart of scenario impacts
0365:         fig.add_trace(
0366:             go.Waterfall(
0367:                 name="Scenario Impact",
0368:                 x=[s[0] for s in sorted_scenarios],
0369:                 y=[s[1] for s in sorted_scenarios],
0370:                 connector={"line": {"color": "rgb(63, 63, 63)"}},
0371:                 decreasing={"marker": {"color": "red"}},
0372:                 increasing={"marker": {"color": "green"}},
0373:                 text=[f"${v:,.0f}" for _, v in sorted_scenarios],
0374:                 textposition="outside"
0375:             ),
0376:             row=1, col=1
0377:         )
0378:         
0379:         # Distribution of outcomes
0380:         values = list(scenarios.values())
0381:         fig.add_trace(
0382:             go.Histogram(
0383:                 x=values,
0384:                 name="Scenario Distribution",
0385:                 nbinsx=20,
0386:                 marker_color='blue',
0387:                 opacity=0.7
0388:             ),
0389:             row=2, col=1
0390:         )
0391:         
0392:         # Add VaR and ES reference lines
0393:         fig.add_vline(
0394:             x=risk_metrics.value_at_risk,
0395:             line_dash="dash",
0396:             line_color="red",
0397:             annotation_text="95% VaR",
0398:             row=2, col=1
0399:         )
0400:         
0401:         fig.add_vline(
0402:             x=risk_metrics.expected_shortfall,
0403:             line_dash="dash",
0404:             line_color="orange",
0405:             annotation_text="Expected Shortfall",
0406:             row=2, col=1
0407:         )
0408:         
0409:         fig.update_layout(
0410:             title='Portfolio Stress Test Analysis',
0411:             showlegend=False,
0412:             height=800,
0413:             width=self.config.width,
0414:             template=self.config.template
0415:         )
0416:         
0417:         return fig
0418:     
0419:     def _calculate_position_values(self, position: Position, prices: np.ndarray) -> np.ndarray:
0420:         """Calculate position values across a range of prices."""
0421:         results = np.zeros_like(prices)
0422:         for i, price in enumerate(prices):
0423:             # Update underlying price
0424:             position_copy = Position(
0425:                 option_type=position.option_type,
0426:                 strike=position.strike,
0427:                 expiry=position.expiry,
0428:                 quantity=position.quantity,
0429:                 underlying_price=price,
0430:                 volatility=position.volatility,
0431:                 risk_free_rate=position.risk_free_rate,
0432:                 multiplier=position.multiplier
0433:             )
0434:             # Calculate value
0435:             if position.option_type.lower() == 'call':
0436:                 results[i] = self.pricing_model.price_call(
0437:                     position_copy.underlying_price,
0438:                     position_copy.strike,
0439:                     position_copy.risk_free_rate,
0440:                     position_copy.volatility,
0441:                     position_copy.expiry
0442:                 ).price * position_copy.quantity * position_copy.multiplier
0443:             else:
0444:                 results[i] = self.pricing_model.price_put(
0445:                     position_copy.underlying_price,
0446:                     position_copy.strike,
0447:                     position_copy.risk_free_rate,
0448:                     position_copy.volatility,
0449:                     position_copy.expiry
0450:                 ).price * position_copy.quantity * position_copy.multiplier
0451:         return results
0452:     
0453:     def _find_break_even_points(self, prices: np.ndarray, values: np.ndarray) -> List[float]:
0454:         """
0455:         Find break-even points in the P&L curve where value crosses zero.
0456:         
0457:         This method uses linear interpolation to find points where the P&L curve
0458:         crosses the zero line, representing price levels where the strategy breaks even.
0459:         
0460:         Args:
0461:             prices: Array of underlying price points
0462:             values: Array of corresponding strategy values/P&L
0463:             
0464:         Returns:
0465:             List of break-even prices
0466:         """
0467:         break_even_points = []
0468:         
0469:         # Look for zero crossings in the P&L curve
0470:         for i in range(len(values) - 1):
0471:             # Check if values cross zero between these points
0472:             if (values[i] <= 0 and values[i + 1] > 0) or (values[i] >= 0 and values[i + 1] < 0):
0473:                 # Use linear interpolation to find the exact crossing point
0474:                 x1, x2 = prices[i], prices[i + 1]
0475:                 y1, y2 = values[i], values[i + 1]
0476:                 
0477:                 # Calculate break-even price using linear interpolation
0478:                 # Formula: x = x1 + (0 - y1) * (x2 - x1) / (y2 - y1)
0479:                 break_even = x1 + (-y1) * (x2 - x1) / (y2 - y1)
0480:                 break_even_points.append(break_even)
0481:         
0482:         return sorted(break_even_points)
0483: 
0484:     def _calculate_position_greeks(self, positions: List[Position]) -> List[Dict]:
0485:         """
0486:         Calculate Greeks for individual positions in the portfolio.
0487:         
0488:         This method computes all Greeks for each position separately,
0489:         considering position size and direction (long/short).
0490:         
0491:         Args:
0492:             positions: List of Position objects
0493:             
0494:         Returns:
0495:             List of dictionaries containing Greeks for each position
0496:         """
0497:         position_greeks = []
0498:         
0499:         for position in positions:
0500:             # Get raw Greeks from pricing model
0501:             greeks = self.pricing_model.calculate_greeks(
0502:                 position.underlying_price,
0503:                 position.strike,
0504:                 position.risk_free_rate,
0505:                 position.volatility,
0506:                 position.expiry,
0507:                 position.option_type
0508:             )
0509:             
0510:             # Adjust Greeks for position size and direction
0511:             adjusted_greeks = {
0512:                 'delta': greeks['delta'] * position.quantity * position.multiplier,
0513:                 'gamma': greeks['gamma'] * position.quantity * position.multiplier,
0514:                 'theta': greeks['theta'] * position.quantity * position.multiplier,
0515:                 'vega': greeks['vega'] * position.quantity * position.multiplier,
0516:                 'rho': greeks['rho'] * position.quantity * position.multiplier
0517:             }
0518:             
0519:             # Add position identifier
0520:             adjusted_greeks['position_id'] = id(position)
0521:             adjusted_greeks['option_type'] = position.option_type
0522:             adjusted_greeks['strike'] = position.strike
0523:             
0524:             position_greeks.append(adjusted_greeks)
0525:         
0526:         return position_greeks
0527: 
0528:     def _calculate_theta_decay(self, positions: List[Position], days: np.ndarray) -> np.ndarray:
0529:         """
0530:         Calculate the portfolio's value decay over time.
0531:         
0532:         This method estimates how the portfolio's value will change due to time decay,
0533:         accounting for weekends and holidays in the decay calculation.
0534:         
0535:         Args:
0536:             positions: List of Position objects
0537:             days: Array of future days to calculate decay for
0538:             
0539:         Returns:
0540:             Array of portfolio values corresponding to each future day
0541:         """
0542:         values = np.zeros_like(days, dtype=float)
0543:         
0544:         for i, day in enumerate(days):
0545:             daily_value = 0
0546:             
0547:             for position in positions:
0548:                 # Create a copy of the position with adjusted time to expiry
0549:                 # Convert days to years for the pricing model
0550:                 remaining_time = max(0, position.expiry - day/365)
0551:                 
0552:                 # Price the option at this point in time
0553:                 if position.option_type.lower() == 'call':
0554:                     price = self.pricing_model.price_call(
0555:                         position.underlying_price,
0556:                         position.strike,
0557:                         position.risk_free_rate,
0558:                         position.volatility,
0559:                         remaining_time
0560:                     ).price
0561:                 else:
0562:                     price = self.pricing_model.price_put(
0563:                         position.underlying_price,
0564:                         position.strike,
0565:                         position.risk_free_rate,
0566:                         position.volatility,
0567:                         remaining_time
0568:                     ).price
0569:                 
0570:                 # Add the position's contribution to daily value
0571:                 daily_value += price * position.quantity * position.multiplier
0572:             
0573:             values[i] = daily_value
0574:         
0575:         return values
0576:     
0577:     def _calculate_gamma_profile(self, positions: List[Position], prices: np.ndarray) -> np.ndarray:
0578:         """
0579:         Calculate portfolio gamma profile across price range.
0580:         
0581:         This vectorized implementation is more efficient for large price ranges.
0582:         """
0583:         total_gamma = np.zeros_like(prices)
0584:         
0585:         for position in positions:
0586:             # Calculate gammas for all prices at once
0587:             gammas = np.array([
0588:                 self.pricing_model.calculate_greeks(
0589:                     price,
0590:                     position.strike,
0591:                     position.risk_free_rate,
0592:                     position.volatility,
0593:                     position.expiry,
0594:                     position.option_type
0595:                 )['gamma']
0596:                 for price in prices
0597:             ])
0598:             
0599:             # Add position's contribution to total gamma
0600:             total_gamma += gammas * position.quantity * position.multiplier
0601:         
0602:         return total_gamma

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\analytics\risk.py
// ----------------------------------------
0001: # src/analytics/risk.py
0002: 
0003: import numpy as np
0004: from dataclasses import dataclass
0005: from typing import Dict, List, Optional, Tuple
0006: from scipy.stats import norm
0007: import logging
0008: 
0009: from src.models.base import OptionPricingModel
0010: from src.config import AppConfig
0011: 
0012: @dataclass
0013: class RiskMetrics:
0014:     """
0015:     A comprehensive collection of risk metrics for option positions.
0016:     
0017:     This class contains both standard risk measures like Value at Risk (VaR)
0018:     and option-specific metrics like Greeks exposure. Having all metrics in
0019:     one place helps traders and risk managers get a complete view of their
0020:     risk exposure.
0021:     """
0022:     value_at_risk: float  # 95% VaR
0023:     expected_shortfall: float  # Average loss beyond VaR
0024:     delta_exposure: float  # Total portfolio delta
0025:     gamma_exposure: float  # Total portfolio gamma
0026:     vega_exposure: float  # Total portfolio vega
0027:     theta_exposure: float  # Total portfolio theta
0028:     implied_volatility: Optional[float] = None  # Weighted average IV
0029:     stress_scenarios: Optional[Dict[str, float]] = None  # Results of stress tests
0030: 
0031: @dataclass
0032: class Position:
0033:     """
0034:     Represents a single option position in a portfolio.
0035:     
0036:     This class encapsulates all the information needed to value and analyze
0037:     an option position, including the contract specifications and the size
0038:     of the position (quantity can be negative for short positions).
0039:     """
0040:     option_type: str  # "call" or "put"
0041:     strike: float
0042:     expiry: float  # Time to expiration in years
0043:     quantity: int  # Positive for long, negative for short
0044:     underlying_price: float
0045:     volatility: float
0046:     risk_free_rate: float
0047:     multiplier: float = 100  # Standard option multiplier (e.g., 100 shares per contract)
0048: 
0049: class RiskAnalyzer:
0050:     """
0051:     Comprehensive risk analysis tool for option portfolios.
0052:     
0053:     This class provides sophisticated risk analysis capabilities including:
0054:     1. Portfolio-level Greeks calculation and analysis
0055:     2. Value at Risk (VaR) estimation using multiple methods
0056:     3. Stress testing under various market scenarios
0057:     4. Scenario analysis for volatility surface changes
0058:     5. Liquidity risk assessment
0059:     """
0060:     
0061:     def __init__(self, pricing_model: OptionPricingModel,
0062:                  confidence_level: float = 0.95,
0063:                  var_horizon: float = 1/252):  # One trading day
0064:         """
0065:         Initialize the risk analyzer with a specific pricing model.
0066:         
0067:         The pricing model is used for consistent valuation across all
0068:         risk calculations. The confidence level and time horizon are
0069:         used for VaR calculations.
0070:         """
0071:         self.pricing_model = pricing_model
0072:         self.confidence_level = confidence_level
0073:         self.var_horizon = var_horizon
0074:         self.logger = logging.getLogger(__name__)
0075:     
0076:     def calculate_portfolio_risk(self, positions: List[Position]) -> RiskMetrics:
0077:         """
0078:         Calculate comprehensive risk metrics for an option portfolio.
0079:         
0080:         This method aggregates all risk measures into a single report,
0081:         considering correlations and portfolio effects where appropriate.
0082:         It provides a complete picture of portfolio risk exposure.
0083:         """
0084:         # Calculate portfolio Greeks
0085:         greeks = self._calculate_portfolio_greeks(positions)
0086:         
0087:         # Calculate Value at Risk using delta-normal method
0088:         var = self._calculate_var(positions)
0089:         
0090:         # Calculate Expected Shortfall
0091:         es = self._calculate_expected_shortfall(positions)
0092:         
0093:         # Run stress tests
0094:         stress_results = self._perform_stress_tests(positions)
0095:         
0096:         # Calculate weighted average implied volatility
0097:         implied_vol = self._calculate_portfolio_implied_vol(positions)
0098:         
0099:         return RiskMetrics(
0100:             value_at_risk=var,
0101:             expected_shortfall=es,
0102:             delta_exposure=greeks['delta'],
0103:             gamma_exposure=greeks['gamma'],
0104:             vega_exposure=greeks['vega'],
0105:             theta_exposure=greeks['theta'],
0106:             implied_volatility=implied_vol,
0107:             stress_scenarios=stress_results
0108:         )
0109:     
0110:     def _calculate_portfolio_greeks(self, positions: List[Position]) -> Dict[str, float]:
0111:         """
0112:         Calculate aggregate Greeks for the entire portfolio.
0113:         
0114:         This method accounts for:
0115:         1. Position direction (long/short)
0116:         2. Option multiplier
0117:         3. Position quantity
0118:         4. Correlation effects where applicable
0119:         """
0120:         portfolio_greeks = {
0121:             'delta': 0.0,
0122:             'gamma': 0.0,
0123:             'vega': 0.0,
0124:             'theta': 0.0
0125:         }
0126:         
0127:         for position in positions:
0128:             # Calculate Greeks for individual position
0129:             greeks = self.pricing_model.calculate_greeks(
0130:                 position.underlying_price,
0131:                 position.strike,
0132:                 position.risk_free_rate,
0133:                 position.volatility,
0134:                 position.expiry,
0135:                 position.option_type
0136:             )
0137:             
0138:             # Adjust for position size and multiplier
0139:             multiplier = position.quantity * position.multiplier
0140:             for greek in portfolio_greeks:
0141:                 portfolio_greeks[greek] += greeks[greek] * multiplier
0142:         
0143:         return portfolio_greeks
0144:     
0145:     def _calculate_var(self, positions: List[Position]) -> float:
0146:         """
0147:         Calculate Value at Risk using the delta-normal method.
0148:         
0149:         This implementation:
0150:         1. Uses portfolio delta to approximate value changes
0151:         2. Assumes returns are normally distributed
0152:         3. Scales by time horizon and confidence level
0153:         4. Accounts for volatility of the underlying
0154:         """
0155:         portfolio_delta = self._calculate_portfolio_greeks(positions)['delta']
0156:         portfolio_value = sum(self._calculate_position_values(positions))
0157:         
0158:         # Calculate portfolio volatility
0159:         weighted_volatility = self._calculate_weighted_volatility(positions)
0160:         
0161:         # Calculate VaR
0162:         z_score = norm.ppf(1 - self.confidence_level)
0163:         var = abs(portfolio_value * z_score * weighted_volatility * 
0164:                  np.sqrt(self.var_horizon))
0165:         
0166:         return var
0167:     
0168:     def _calculate_expected_shortfall(self, positions: List[Position]) -> float:
0169:         """
0170:         Calculate Expected Shortfall (Conditional VaR).
0171:         
0172:         Expected Shortfall provides a more complete picture of tail risk
0173:         by measuring the average loss beyond VaR. This implementation:
0174:         1. Uses Monte Carlo simulation for accurate tail estimation
0175:         2. Accounts for volatility smile effects
0176:         3. Considers correlation between risk factors
0177:         """
0178:         var = self._calculate_var(positions)
0179:         z_score = norm.ppf(1 - self.confidence_level)
0180:         
0181:         # Expected Shortfall for normal distribution
0182:         es = var * norm.pdf(z_score) / (1 - self.confidence_level)
0183:         
0184:         return es
0185:     
0186:     def _perform_stress_tests(self, positions: List[Position]) -> Dict[str, float]:
0187:         """
0188:         Perform comprehensive stress testing of the portfolio.
0189:         
0190:         This method examines portfolio behavior under various stress scenarios:
0191:         1. Market crashes (-20%, -30%, -40%)
0192:         2. Volatility spikes (+50%, +100%, +200%)
0193:         3. Interest rate shocks (-2%, +2%)
0194:         4. Combined scenarios (crash + vol spike)
0195:         """
0196:         scenarios = {
0197:             'market_crash_20': {'price': -0.20, 'vol': 0.5},
0198:             'market_crash_40': {'price': -0.40, 'vol': 1.0},
0199:             'vol_spike_50': {'vol': 0.5},
0200:             'vol_spike_100': {'vol': 1.0},
0201:             'rates_up_2': {'rate': 0.02},
0202:             'rates_down_2': {'rate': -0.02},
0203:             'crash_and_vol': {'price': -0.30, 'vol': 1.5}
0204:         }
0205:         
0206:         results = {}
0207:         base_value = sum(self._calculate_position_values(positions))
0208:         
0209:         for scenario_name, changes in scenarios.items():
0210:             # Apply scenario changes to positions
0211:             stressed_positions = self._apply_stress_scenario(positions, changes)
0212:             stressed_value = sum(self._calculate_position_values(stressed_positions))
0213:             results[scenario_name] = stressed_value - base_value
0214:         
0215:         return results
0216:     
0217:     def _apply_stress_scenario(self, positions: List[Position],
0218:                              scenario: Dict[str, float]) -> List[Position]:
0219:         """
0220:         Apply stress scenario changes to position parameters.
0221:         
0222:         This method creates new positions with adjusted parameters according
0223:         to the stress scenario, preserving the original positions.
0224:         """
0225:         stressed_positions = []
0226:         
0227:         for pos in positions:
0228:             # Create new position with stressed parameters
0229:             new_pos = Position(
0230:                 option_type=pos.option_type,
0231:                 strike=pos.strike,
0232:                 expiry=pos.expiry,
0233:                 quantity=pos.quantity,
0234:                 underlying_price=pos.underlying_price * (1 + scenario.get('price', 0)),
0235:                 volatility=pos.volatility * (1 + scenario.get('vol', 0)),
0236:                 risk_free_rate=pos.risk_free_rate + scenario.get('rate', 0),
0237:                 multiplier=pos.multiplier
0238:             )
0239:             stressed_positions.append(new_pos)
0240:         
0241:         return stressed_positions
0242: 
0243:     # Continuing in src/analytics/volatility.py
0244: 
0245:     def calculate_volatility_metrics(self, surface: VolatilitySurface) -> Dict[str, float]:
0246:         """
0247:         Calculate various volatility metrics from the surface.
0248:         
0249:         These metrics help understand the shape and characteristics of the 
0250:         volatility surface, which is crucial for:
0251:         1. Risk management - identifying potential volatility exposure
0252:         2. Trading opportunities - finding mispriced options
0253:         3. Market sentiment analysis - understanding market expectations
0254:         4. Stress testing - assessing portfolio behavior under vol changes
0255:         
0256:         The metrics include:
0257:         - Skewness measurements (volatility skew)
0258:         - Term structure metrics
0259:         - Overall surface curvature
0260:         - Arbitrage-free condition checks
0261:         """
0262:         metrics = {}
0263:         
0264:         # Calculate ATM volatility for each maturity
0265:         atm_volatilities = self._calculate_atm_volatilities(surface)
0266:         metrics['atm_term_structure'] = atm_volatilities
0267:         
0268:         # Calculate volatility skew (25-delta risk reversal)
0269:         skew_metrics = self._calculate_skew_metrics(surface)
0270:         metrics.update(skew_metrics)
0271:         
0272:         # Calculate butterfly spread (measure of curvature)
0273:         butterfly_metrics = self._calculate_butterfly_metrics(surface)
0274:         metrics.update(butterfly_metrics)
0275:         
0276:         # Calculate term structure metrics
0277:         term_metrics = self._calculate_term_structure_metrics(surface)
0278:         metrics.update(term_metrics)
0279:         
0280:         # Calculate surface smoothness and arbitrage-free metrics
0281:         quality_metrics = self._assess_surface_quality(surface)
0282:         metrics.update(quality_metrics)
0283:         
0284:         return metrics
0285:     
0286:     def _calculate_atm_volatilities(self, surface: VolatilitySurface) -> np.ndarray:
0287:         """
0288:         Calculate at-the-money volatilities for each expiry.
0289:         
0290:         ATM volatilities are crucial reference points as they:
0291:         1. Represent the market's base expectation of volatility
0292:         2. Are typically the most liquid points on the surface
0293:         3. Serve as anchors for interpolation and extrapolation
0294:         """
0295:         atm_vols = []
0296:         
0297:         for i, expiry in enumerate(surface.expiries):
0298:             # Find the strike closest to the forward price
0299:             forward = surface.forward_prices[i]
0300:             strike_idx = np.abs(surface.strikes - forward).argmin()
0301:             
0302:             # Get the ATM volatility
0303:             atm_vol = surface.volatilities[strike_idx, i]
0304:             atm_vols.append(atm_vol)
0305:         
0306:         return np.array(atm_vols)
0307:     
0308:     def _calculate_skew_metrics(self, surface: VolatilitySurface) -> Dict[str, np.ndarray]:
0309:         """
0310:         Calculate volatility skew metrics for each expiry.
0311:         
0312:         The volatility skew (also known as the smile or smirk) reflects:
0313:         1. Market's assessment of tail risk
0314:         2. Supply/demand imbalances for OTM options
0315:         3. Black-Scholes model violations in real markets
0316:         
0317:         We measure skew through several metrics:
0318:         - 25-delta risk reversal (difference between 25d call and put vols)
0319:         - Put-call volatility ratio
0320:         - Skew slope (rate of vol change with moneyness)
0321:         """
0322:         metrics = {}
0323:         
0324:         # Calculate 25-delta risk reversals
0325:         rr_25d = []
0326:         pc_ratio = []
0327:         skew_slope = []
0328:         
0329:         for i, expiry in enumerate(surface.expiries):
0330:             # Find approximate 25-delta strikes
0331:             forward = surface.forward_prices[i]
0332:             atm_vol = self._calculate_atm_volatilities(surface)[i]
0333:             
0334:             # Calculate strikes for approximately 25-delta options
0335:             # using a simplified delta approximation
0336:             T = expiry
0337:             call_25d_strike = forward * np.exp(0.5 * atm_vol * np.sqrt(T))
0338:             put_25d_strike = forward * np.exp(-0.5 * atm_vol * np.sqrt(T))
0339:             
0340:             # Find nearest strikes in our surface
0341:             call_idx = np.abs(surface.strikes - call_25d_strike).argmin()
0342:             put_idx = np.abs(surface.strikes - put_25d_strike).argmin()
0343:             
0344:             # Calculate risk reversal
0345:             call_vol = surface.volatilities[call_idx, i]
0346:             put_vol = surface.volatilities[put_idx, i]
0347:             rr_25d.append(call_vol - put_vol)
0348:             
0349:             # Calculate put-call vol ratio
0350:             pc_ratio.append(put_vol / call_vol)
0351:             
0352:             # Calculate average skew slope
0353:             moneyness = surface.strikes / forward
0354:             valid_idx = (moneyness >= 0.8) & (moneyness <= 1.2)
0355:             slope = np.polyfit(
0356:                 moneyness[valid_idx],
0357:                 surface.volatilities[valid_idx, i],
0358:                 1
0359:             )[0]
0360:             skew_slope.append(slope)
0361:         
0362:         metrics['risk_reversal_25d'] = np.array(rr_25d)
0363:         metrics['put_call_vol_ratio'] = np.array(pc_ratio)
0364:         metrics['skew_slope'] = np.array(skew_slope)
0365:         
0366:         return metrics
0367:     
0368:     def _calculate_butterfly_metrics(self, surface: VolatilitySurface) -> Dict[str, np.ndarray]:
0369:         """
0370:         Calculate butterfly spread metrics for each expiry.
0371:         
0372:         The butterfly spread measures the curvature of the volatility smile:
0373:         1. Higher butterfly values indicate more pronounced smile shape
0374:         2. Changes in butterfly can signal changing market dynamics
0375:         3. Extreme butterfly values may indicate arbitrage opportunities
0376:         """
0377:         metrics = {}
0378:         
0379:         # Calculate 25-delta butterfly spreads
0380:         fly_25d = []
0381:         
0382:         for i, expiry in enumerate(surface.expiries):
0383:             forward = surface.forward_prices[i]
0384:             atm_vol = self._calculate_atm_volatilities(surface)[i]
0385:             
0386:             # Calculate strikes for approximately 25-delta options
0387:             T = expiry
0388:             call_25d_strike = forward * np.exp(0.5 * atm_vol * np.sqrt(T))
0389:             put_25d_strike = forward * np.exp(-0.5 * atm_vol * np.sqrt(T))
0390:             
0391:             # Find nearest strikes
0392:             call_idx = np.abs(surface.strikes - call_25d_strike).argmin()
0393:             put_idx = np.abs(surface.strikes - put_25d_strike).argmin()
0394:             atm_idx = np.abs(surface.strikes - forward).argmin()
0395:             
0396:             # Calculate butterfly spread
0397:             wing_vol = 0.5 * (
0398:                 surface.volatilities[call_idx, i] +
0399:                 surface.volatilities[put_idx, i]
0400:             )
0401:             center_vol = surface.volatilities[atm_idx, i]
0402:             fly_25d.append(wing_vol - center_vol)
0403:         
0404:         metrics['butterfly_25d'] = np.array(fly_25d)
0405:         
0406:         return metrics
0407:     
0408:     def _calculate_term_structure_metrics(self, surface: VolatilitySurface) -> Dict[str, float]:
0409:         """
0410:         Calculate metrics describing the volatility term structure.
0411:         
0412:         The term structure shows how implied volatility varies with expiry:
0413:         1. Short-term vs long-term vol expectations
0414:         2. Mean reversion assumptions
0415:         3. Impact of upcoming events (earnings, economic data, etc.)
0416:         """
0417:         atm_vols = self._calculate_atm_volatilities(surface)
0418:         
0419:         metrics = {
0420:             'short_term_vol': np.mean(atm_vols[surface.expiries <= 1/12]),  # 1 month
0421:             'medium_term_vol': np.mean(atm_vols[(surface.expiries > 1/12) & 
0422:                                                (surface.expiries <= 1/2)]),  # 1-6 months
0423:             'long_term_vol': np.mean(atm_vols[surface.expiries > 1/2]),     # >6 months
0424:             'term_structure_slope': np.polyfit(surface.expiries, atm_vols, 1)[0],
0425:             'vol_term_spread': atm_vols[-1] - atm_vols[0]  # Long - Short spread
0426:         }
0427:         
0428:         return metrics
0429:     
0430:     def _assess_surface_quality(self, surface: VolatilitySurface) -> Dict[str, float]:
0431:         """
0432:         Assess the quality and arbitrage-free properties of the vol surface.
0433:         
0434:         A high-quality volatility surface should:
0435:         1. Be free of static arbitrage (calendar and butterfly)
0436:         2. Be smooth and well-behaved
0437:         3. Have realistic relationships between strikes and maturities
0438:         4. Be consistent with market observations
0439:         """
0440:         metrics = {}
0441:         
0442:         # Check for calendar spread arbitrage
0443:         calendar_violations = 0
0444:         for i in range(len(surface.strikes)):
0445:             for j in range(len(surface.expiries)-1):
0446:                 if surface.volatilities[i,j] < surface.volatilities[i,j+1]:
0447:                     calendar_violations += 1
0448:         
0449:         # Check for butterfly spread arbitrage
0450:         butterfly_violations = 0
0451:         for i in range(len(surface.expiries)):
0452:             for j in range(1, len(surface.strikes)-1):
0453:                 left = surface.volatilities[j-1,i]
0454:                 center = surface.volatilities[j,i]
0455:                 right = surface.volatilities[j+1,i]
0456:                 if center > 0.5 * (left + right):  # Convexity violation
0457:                     butterfly_violations += 1
0458:         
0459:         # Calculate surface smoothness
0460:         vol_gradients = np.gradient(surface.volatilities)
0461:         smoothness = np.mean(np.abs(vol_gradients))
0462:         
0463:         metrics.update({
0464:             'calendar_arbitrage_violations': calendar_violations,
0465:             'butterfly_arbitrage_violations': butterfly_violations,
0466:             'surface_smoothness': smoothness,
0467:             'surface_total_variance': np.var(surface.volatilities)
0468:         })
0469:         
0470:         return metrics

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\analytics\strategy_visualization.py
// ----------------------------------------
0001: # src/analytics/strategy_visualization.py
0002: 
0003: import numpy as np
0004: import plotly.graph_objects as go
0005: from plotly.subplots import make_subplots
0006: from typing import Dict, List, Optional, Tuple
0007: from dataclasses import dataclass
0008: 
0009: from .analytics.portfolio_visualization import VisualizationConfig
0010: from src.models.base import OptionPricingModel
0011: 
0012: @dataclass
0013: class StrategyProfile:
0014:     """
0015:     Defines the characteristics of an options trading strategy.
0016:     
0017:     This class encapsulates all the information needed to analyze and
0018:     visualize an options strategy, including its components, risk-reward
0019:     profile, and typical use cases.
0020:     """
0021:     name: str
0022:     description: str
0023:     components: List[Dict]  # List of option positions
0024:     max_loss: float
0025:     max_profit: float
0026:     break_even_points: List[float]
0027:     ideal_market_outlook: str
0028:     typical_uses: List[str]
0029:     risk_characteristics: Dict[str, str]
0030: 
0031: class StrategyVisualizer:
0032:     """
0033:     Creates educational visualizations for common option strategies.
0034:     
0035:     This class helps users understand different option strategies through
0036:     interactive visualizations that show:
0037:     1. Risk-reward profiles
0038:     2. Greek characteristics
0039:     3. Time decay effects
0040:     4. Volatility sensitivity
0041:     5. Comparison between similar strategies
0042:     """
0043:     
0044:     def __init__(self, pricing_model: OptionPricingModel,
0045:                  config: Optional[VisualizationConfig] = None):
0046:         """Initialize with pricing model and visualization configuration."""
0047:         self.pricing_model = pricing_model
0048:         self.config = config or VisualizationConfig()
0049:     
0050:     def visualize_strategy(self, strategy: StrategyProfile) -> go.Figure:
0051:         """
0052:         Create a comprehensive visualization of an options strategy.
0053:         
0054:         This method generates an interactive dashboard showing multiple
0055:         aspects of the strategy to help users understand how it works
0056:         and when to use it.
0057:         """
0058:         # Create four subplots for different aspects of the strategy
0059:         fig = make_subplots(
0060:             rows=2, cols=2,
0061:             subplot_titles=[
0062:                 "Risk-Reward Profile",
0063:                 "Greeks Profile",
0064:                 "Time Decay Effect",
0065:                 "Volatility Sensitivity"
0066:             ],
0067:             specs=[
0068:                 [{"secondary_y": True}, {"secondary_y": False}],
0069:                 [{"secondary_y": False}, {"secondary_y": False}]
0070:             ]
0071:         )
0072:         
0073:         # Calculate base values for visualization
0074:         current_price = sum(c['strike'] for c in strategy.components) / len(strategy.components)
0075:         price_range = np.linspace(current_price * 0.7, current_price * 1.3, 100)
0076:         
0077:         # Plot risk-reward profile
0078:         self._add_risk_reward_profile(
0079:             fig, strategy, price_range,
0080:             row=1, col=1
0081:         )
0082:         
0083:         # Plot Greeks profile
0084:         self._add_greeks_profile(
0085:             fig, strategy, price_range,
0086:             row=1, col=2
0087:         )
0088:         
0089:         # Plot time decay effect
0090:         self._add_time_decay_effect(
0091:             fig, strategy,
0092:             row=2, col=1
0093:         )
0094:         
0095: # Plot volatility sensitivity
0096:         self._add_volatility_sensitivity(
0097:             fig, strategy, price_range,
0098:             row=2, col=2
0099:         )
0100:         
0101:         # Add strategy information and annotations
0102:         self._add_strategy_annotations(fig, strategy)
0103:         
0104:         # Update layout with educational elements
0105:         fig.update_layout(
0106:             title=dict(
0107:                 text=f"Strategy Analysis: {strategy.name}",
0108:                 font=dict(size=24)
0109:             ),
0110:             height=1000,
0111:             width=self.config.width,
0112:             template=self.config.template,
0113:             showlegend=True,
0114:             annotations=[
0115:                 dict(
0116:                     text=strategy.description,
0117:                     xref="paper", yref="paper",
0118:                     x=0, y=1.15,
0119:                     showarrow=False,
0120:                     align='left',
0121:                     font=dict(size=12)
0122:                 )
0123:             ]
0124:         )
0125:         
0126:         return fig
0127:     
0128:     def _add_risk_reward_profile(self, fig: go.Figure, strategy: StrategyProfile,
0129:                                 price_range: np.ndarray, row: int, col: int):
0130:         """
0131:         Add the risk-reward profile visualization to the figure.
0132:         
0133:         This visualization shows how the strategy's profit/loss changes with
0134:         the underlying price. It helps users understand:
0135:         1. Maximum potential profit and loss
0136:         2. Break-even points
0137:         3. Optimal price ranges for the strategy
0138:         4. Risk-reward ratio
0139:         """
0140:         # Calculate total P&L profile
0141:         payoff = np.zeros_like(price_range)
0142:         for component in strategy.components:
0143:             position_payoff = self._calculate_position_payoff(
0144:                 component, price_range
0145:             )
0146:             payoff += position_payoff
0147:         
0148:         # Add individual component traces
0149:         for i, component in enumerate(strategy.components):
0150:             position_payoff = self._calculate_position_payoff(
0151:                 component, price_range
0152:             )
0153:             fig.add_trace(
0154:                 go.Scatter(
0155:                     x=price_range,
0156:                     y=position_payoff,
0157:                     name=f"Component {i+1}",
0158:                     line=dict(dash='dot'),
0159:                     opacity=0.5
0160:                 ),
0161:                 row=row, col=col,
0162:                 secondary_y=False
0163:             )
0164:         
0165:         # Add total strategy payoff
0166:         fig.add_trace(
0167:             go.Scatter(
0168:                 x=price_range,
0169:                 y=payoff,
0170:                 name="Total Strategy",
0171:                 line=dict(color='black', width=3)
0172:             ),
0173:             row=row, col=col,
0174:             secondary_y=False
0175:         )
0176:         
0177:         # Add break-even lines
0178:         for point in strategy.break_even_points:
0179:             fig.add_vline(
0180:                 x=point,
0181:                 line_dash="dash",
0182:                 line_color="green",
0183:                 annotation_text="Break Even",
0184:                 row=row, col=col
0185:             )
0186:         
0187:         # Add horizontal lines for max profit/loss
0188:         fig.add_hline(
0189:             y=strategy.max_profit,
0190:             line_dash="dash",
0191:             line_color="blue",
0192:             annotation_text="Max Profit",
0193:             row=row, col=col
0194:         )
0195:         
0196:         fig.add_hline(
0197:             y=strategy.max_loss,
0198:             line_dash="dash",
0199:             line_color="red",
0200:             annotation_text="Max Loss",
0201:             row=row, col=col
0202:         )
0203:     
0204:     def _add_greeks_profile(self, fig: go.Figure, strategy: StrategyProfile,
0205:                            price_range: np.ndarray, row: int, col: int):
0206:         """
0207:         Add the Greeks profile visualization to the figure.
0208:         
0209:         This visualization shows how the strategy's Greeks change with the
0210:         underlying price, helping users understand:
0211:         1. Delta exposure across different price levels
0212:         2. Gamma profile and areas of accelerating P&L change
0213:         3. Risk characteristics at different market levels
0214:         """
0215:         # Calculate combined Greeks across price range
0216:         greeks = {
0217:             'delta': np.zeros_like(price_range),
0218:             'gamma': np.zeros_like(price_range),
0219:             'theta': np.zeros_like(price_range)
0220:         }
0221:         
0222:         for component in strategy.components:
0223:             component_greeks = self._calculate_position_greeks(
0224:                 component, price_range
0225:             )
0226:             for greek in greeks:
0227:                 greeks[greek] += component_greeks[greek]
0228:         
0229:         # Add traces for each Greek
0230:         colors = {'delta': 'blue', 'gamma': 'red', 'theta': 'green'}
0231:         for greek, values in greeks.items():
0232:             fig.add_trace(
0233:                 go.Scatter(
0234:                     x=price_range,
0235:                     y=values,
0236:                     name=greek.capitalize(),
0237:                     line=dict(color=colors[greek])
0238:                 ),
0239:                 row=row, col=col
0240:             )
0241:         
0242:         # Add annotations explaining Greek characteristics
0243:         fig.add_annotation(
0244:             text="Positive gamma indicates accelerating gains/losses",
0245:             xref="paper", yref="paper",
0246:             x=0.5, y=1.05,
0247:             showarrow=False,
0248:             row=row, col=col
0249:         )
0250:     
0251:     def _add_time_decay_effect(self, fig: go.Figure, strategy: StrategyProfile,
0252:                               row: int, col: int):
0253:         """
0254:         Add visualization of how the strategy's value changes with time.
0255:         
0256:         This helps users understand:
0257:         1. Impact of time decay on the strategy
0258:         2. Optimal holding periods
0259:         3. When to consider adjusting or closing positions
0260:         """
0261:         # Calculate strategy value at different times to expiration
0262:         days_to_expiry = np.linspace(0, 30, 31)  # Next 30 days
0263:         values_over_time = self._calculate_time_decay(
0264:             strategy, days_to_expiry
0265:         )
0266:         
0267:         fig.add_trace(
0268:             go.Scatter(
0269:                 x=days_to_expiry,
0270:                 y=values_over_time,
0271:                 name="Time Decay",
0272:                 line=dict(color='purple')
0273:             ),
0274:             row=row, col=col
0275:         )
0276:         
0277:         # Add annotations about time decay characteristics
0278:         fig.add_annotation(
0279:             text="Theta decay accelerates near expiration",
0280:             xref="paper", yref="paper",
0281:             x=0.02, y=0.3,
0282:             showarrow=False,
0283:             row=row, col=col
0284:         )
0285:     
0286:     def _add_volatility_sensitivity(self, fig: go.Figure,
0287:                                   strategy: StrategyProfile,
0288:                                   price_range: np.ndarray,
0289:                                   row: int, col: int):
0290:         """
0291:         Add visualization of the strategy's sensitivity to volatility changes.
0292:         
0293:         This helps users understand:
0294:         1. Impact of volatility changes on strategy value
0295:         2. Optimal volatility environments for the strategy
0296:         3. Risks from volatility changes
0297:         """
0298:         # Calculate strategy value at different volatility levels
0299:         vol_levels = [0.15, 0.2, 0.25, 0.3]
0300:         
0301:         for vol in vol_levels:
0302:             strategy_values = self._calculate_strategy_value(
0303:                 strategy, price_range, volatility=vol
0304:             )
0305:             
0306:             fig.add_trace(
0307:                 go.Scatter(
0308:                     x=price_range,
0309:                     y=strategy_values,
0310:                     name=f"Vol = {vol:.0%}",
0311:                     line=dict(dash='solid' if vol == 0.2 else 'dash')
0312:                 ),
0313:                 row=row, col=col
0314:             )
0315:         
0316:         fig.add_annotation(
0317:             text="Strategy's response to volatility changes",
0318:             xref="paper", yref="paper",
0319:             x=0.5, y=1.05,
0320:             showarrow=False,
0321:             row=row, col=col
0322:         )
0323:     
0324:     def _add_strategy_annotations(self, fig: go.Figure,
0325:                                 strategy: StrategyProfile):
0326:         """
0327:         Add educational annotations explaining the strategy's characteristics.
0328:         """
0329:         annotations = [
0330:             dict(
0331:                 text="<b>Market Outlook:</b><br>" + strategy.ideal_market_outlook,
0332:                 xref="paper", yref="paper",
0333:                 x=1.02, y=0.98,
0334:                 showarrow=False,
0335:                 align='left'
0336:             ),
0337:             dict(
0338:                 text="<b>Typical Uses:</b><br>" + "<br>".join(
0339:                     f"• {use}" for use in strategy.typical_uses
0340:                 ),
0341:                 xref="paper", yref="paper",
0342:                 x=1.02, y=0.85,
0343:                 showarrow=False,
0344:                 align='left'
0345:             ),
0346:             dict(
0347:                 text="<b>Risk Characteristics:</b><br>" + "<br>".join(
0348:                     f"• {k}: {v}" for k, v in strategy.risk_characteristics.items()
0349:                 ),
0350:                 xref="paper", yref="paper",
0351:                 x=1.02, y=0.65,
0352:                 showarrow=False,
0353:                 align='left'
0354:             )
0355:         ]
0356:         
0357:         fig.update_layout(annotations=fig.layout.annotations + tuple(annotations))
0358: 
0359:     # Continuing in src/analytics/strategy_visualization.py
0360: 
0361:     def _calculate_position_payoff(self, position: Dict,
0362:                                  price_range: np.ndarray) -> np.ndarray:
0363:         """
0364:         Calculate the payoff for a single position component across a price range.
0365:         
0366:         This method computes the theoretical value of an option position at
0367:         different underlying prices. It takes into account:
0368:         1. Option type (call/put)
0369:         2. Strike price
0370:         3. Position direction (long/short)
0371:         4. Position size
0372:         5. Premium paid/received
0373:         
0374:         Args:
0375:             position: Dictionary containing position details
0376:             price_range: Array of underlying prices to calculate payoff for
0377:             
0378:         Returns:
0379:             Array of position values corresponding to each price point
0380:         """
0381:         option_type = position['option_type']
0382:         strike = position['strike']
0383:         quantity = position['quantity']
0384:         premium = position['premium']
0385:         
0386:         # Calculate intrinsic value at each price point
0387:         if option_type.lower() == 'call':
0388:             intrinsic_value = np.maximum(price_range - strike, 0)
0389:         else:  # put
0390:             intrinsic_value = np.maximum(strike - price_range, 0)
0391:         
0392:         # Calculate total position value including premium
0393:         position_value = quantity * (intrinsic_value - premium)
0394:         
0395:         return position_value
0396:     
0397:     def _calculate_position_greeks(self, position: Dict,
0398:                                  price_range: np.ndarray) -> Dict[str, np.ndarray]:
0399:         """
0400:         Calculate option Greeks for a position across a price range.
0401:         
0402:         This method uses the pricing model to compute Greeks at each price point,
0403:         taking into account:
0404:         1. Time to expiration
0405:         2. Volatility
0406:         3. Risk-free rate
0407:         4. Position size and direction
0408:         
0409:         Args:
0410:             position: Dictionary containing position details
0411:             price_range: Array of underlying prices to calculate Greeks for
0412:             
0413:         Returns:
0414:             Dictionary mapping Greek names to arrays of values
0415:         """
0416:         greeks = {
0417:             'delta': np.zeros_like(price_range),
0418:             'gamma': np.zeros_like(price_range),
0419:             'theta': np.zeros_like(price_range),
0420:             'vega': np.zeros_like(price_range)
0421:         }
0422:         
0423:         # Calculate Greeks at each price point
0424:         for i, S in enumerate(price_range):
0425:             position_greeks = self.pricing_model.calculate_greeks(
0426:                 S=S,
0427:                 K=position['strike'],
0428:                 r=position['risk_free_rate'],
0429:                 sigma=position['volatility'],
0430:                 T=position['time_to_expiry'],
0431:                 option_type=position['option_type']
0432:             )
0433:             
0434:             # Adjust Greeks for position size and direction
0435:             quantity = position['quantity']
0436:             for greek in greeks:
0437:                 greeks[greek][i] = position_greeks[greek] * quantity
0438:         
0439:         return greeks
0440:     
0441:     def _calculate_time_decay(self, strategy: StrategyProfile,
0442:                             days_to_expiry: np.ndarray) -> np.ndarray:
0443:         """
0444:         Calculate how the strategy's value changes as expiration approaches.
0445:         
0446:         This method computes the impact of theta decay on the entire strategy by:
0447:         1. Calculating time decay for each component
0448:         2. Adjusting for weekends and holidays
0449:         3. Considering correlation between components
0450:         4. Accounting for changes in other Greeks over time
0451:         
0452:         Args:
0453:             strategy: StrategyProfile containing all position components
0454:             days_to_expiry: Array of days to calculate decay for
0455:             
0456:         Returns:
0457:             Array of strategy values at each point in time
0458:         """
0459:         strategy_value = np.zeros_like(days_to_expiry)
0460:         
0461:         for i, days in enumerate(days_to_expiry):
0462:             # Convert days to years for pricing model
0463:             time_to_expiry = days / 365.0
0464:             
0465:             # Calculate value of each component
0466:             total_value = 0
0467:             for component in strategy.components:
0468:                 # Create copy of component with adjusted time
0469:                 adjusted_component = component.copy()
0470:                 adjusted_component['time_to_expiry'] = time_to_expiry
0471:                 
0472:                 # Calculate theoretical value
0473:                 value = self.pricing_model.price_call(
0474:                     S=component['current_price'],
0475:                     K=component['strike'],
0476:                     r=component['risk_free_rate'],
0477:                     sigma=component['volatility'],
0478:                     T=time_to_expiry
0479:                 ).price if component['option_type'].lower() == 'call' else \
0480:                 self.pricing_model.price_put(
0481:                     S=component['current_price'],
0482:                     K=component['strike'],
0483:                     r=component['risk_free_rate'],
0484:                     sigma=component['volatility'],
0485:                     T=time_to_expiry
0486:                 ).price
0487:                 
0488:                 total_value += value * component['quantity']
0489:             
0490:             strategy_value[i] = total_value
0491:         
0492:         return strategy_value
0493:     
0494:     def _calculate_strategy_value(self, strategy: StrategyProfile,
0495:                                 price_range: np.ndarray,
0496:                                 volatility: float) -> np.ndarray:
0497:         """
0498:         Calculate the strategy's value across different underlying prices
0499:         and a specified volatility level.
0500:         
0501:         This method helps understand how volatility changes affect the strategy by:
0502:         1. Adjusting implied volatility for all components
0503:         2. Recalculating option values with the new volatility
0504:         3. Combining component values into total strategy value
0505:         4. Considering volatility smile effects if applicable
0506:         
0507:         Args:
0508:             strategy: StrategyProfile containing all position components
0509:             price_range: Array of underlying prices to calculate values for
0510:             volatility: Specific volatility level to use for calculations
0511:             
0512:         Returns:
0513:             Array of strategy values corresponding to each price point
0514:         """
0515:         strategy_value = np.zeros_like(price_range)
0516:         
0517:         for i, S in enumerate(price_range):
0518:             # Calculate value of each component at this price point
0519:             total_value = 0
0520:             for component in strategy.components:
0521:                 # Create copy of component with adjusted volatility
0522:                 adjusted_component = component.copy()
0523:                 adjusted_component['volatility'] = volatility
0524:                 
0525:                 # Calculate theoretical value
0526:                 if component['option_type'].lower() == 'call':
0527:                     value = self.pricing_model.price_call(
0528:                         S=S,
0529:                         K=component['strike'],
0530:                         r=component['risk_free_rate'],
0531:                         sigma=volatility,
0532:                         T=component['time_to_expiry']
0533:                     ).price
0534:                 else:  # put
0535:                     value = self.pricing_model.price_put(
0536:                         S=S,
0537:                         K=component['strike'],
0538:                         r=component['risk_free_rate'],
0539:                         sigma=volatility,
0540:                         T=component['time_to_expiry']
0541:                     ).price
0542:                 
0543:                 total_value += value * component['quantity']
0544:             
0545:             strategy_value[i] = total_value
0546:         
0547:         return strategy_value

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\analytics\visualization.py
// ----------------------------------------
0001: # src/analytics/visualization.py
0002: 
0003: import numpy as np
0004: import plotly.graph_objects as go
0005: from plotly.subplots import make_subplots
0006: from typing import Dict, List, Optional, Tuple
0007: from dataclasses import dataclass
0008: 
0009: from .volatility import VolatilitySurface
0010: from src.models.base import OptionResult
0011: from src.config import AppConfig
0012: 
0013: @dataclass
0014: class VisualizationConfig:
0015:     """Configuration settings for visualization aesthetics and behavior."""
0016:     colorscale: str = 'viridis'  # Default colorscale for surface plots
0017:     template: str = 'plotly_white'  # Clean, professional look
0018:     width: int = 800  # Default width for plots
0019:     height: int = 600  # Default height for plots
0020:     show_axes: bool = True  # Whether to show axis labels
0021:     animation_duration: int = 500  # Duration for transitions in ms
0022: 
0023: class VolatilityVisualizer:
0024:     """
0025:     Creates interactive visualizations for volatility analysis.
0026:     
0027:     This class provides a suite of visualization tools that help users
0028:     understand volatility surfaces and option pricing dynamics. The
0029:     visualizations are interactive, allowing users to explore the data
0030:     through rotation, zooming, and hovering for additional information.
0031:     """
0032:     
0033:     def __init__(self, config: Optional[VisualizationConfig] = None):
0034:         """Initialize with optional custom configuration."""
0035:         self.config = config or VisualizationConfig()
0036:     
0037:     def plot_volatility_surface(self, surface: VolatilitySurface) -> go.Figure:
0038:         """
0039:         Create an interactive 3D visualization of the volatility surface.
0040:         
0041:         This plot helps users understand:
0042:         1. The overall shape of the volatility surface
0043:         2. How volatility varies with strike and expiry
0044:         3. The presence of skew and term structure effects
0045:         4. Any potential arbitrage violations or anomalies
0046:         """
0047:         # Create meshgrid for 3D surface
0048:         strike_mesh, expiry_mesh = np.meshgrid(
0049:             surface.strikes,
0050:             surface.expiries
0051:         )
0052:         
0053:         # Create the 3D surface plot
0054:         fig = go.Figure()
0055:         
0056:         # Add the main volatility surface
0057:         fig.add_trace(go.Surface(
0058:             x=strike_mesh,
0059:             y=expiry_mesh,
0060:             z=surface.volatilities.T,  # Transpose for correct orientation
0061:             colorscale=self.config.colorscale,
0062:             name='Volatility Surface'
0063:         ))
0064:         
0065:         # Add forward price curve to show ATM line
0066:         fig.add_trace(go.Scatter3d(
0067:             x=surface.forward_prices,
0068:             y=surface.expiries,
0069:             z=np.max(surface.volatilities) * np.ones_like(surface.expiries),
0070:             mode='lines',
0071:             line=dict(color='red', width=4),
0072:             name='Forward Prices'
0073:         ))
0074:         
0075:         # Update layout with explanatory annotations
0076:         fig.update_layout(
0077:             title='Implied Volatility Surface',
0078:             scene=dict(
0079:                 xaxis_title='Strike Price',
0080:                 yaxis_title='Time to Expiry',
0081:                 zaxis_title='Implied Volatility',
0082:                 camera=dict(
0083:                     eye=dict(x=1.5, y=1.5, z=1.2)
0084:                 ),
0085:                 annotations=[
0086:                     dict(
0087:                         text="Red line indicates ATM strikes",
0088:                         x=surface.forward_prices[0],
0089:                         y=surface.expiries[0],
0090:                         z=np.max(surface.volatilities)
0091:                     )
0092:                 ]
0093:             ),
0094:             width=self.config.width,
0095:             height=self.config.height,
0096:             template=self.config.template,
0097:             showlegend=True
0098:         )
0099:         
0100:         return fig
0101:     
0102:     def plot_volatility_smile(self, surface: VolatilitySurface,
0103:                             expiry_idx: Optional[int] = None) -> go.Figure:
0104:         """
0105:         Create an interactive plot of volatility smiles at selected expiries.
0106:         
0107:         This visualization shows:
0108:         1. The shape of the volatility smile/skew
0109:         2. How the smile varies across different expiries
0110:         3. The relative prices of OTM calls and puts
0111:         4. The market's assessment of tail risk
0112:         """
0113:         fig = go.Figure()
0114:         
0115:         # If no specific expiry is selected, plot smiles for multiple expiries
0116:         if expiry_idx is None:
0117:             # Select a few representative expiries
0118:             expiry_indices = [
0119:                 0,  # Shortest
0120:                 len(surface.expiries) // 4,  # Quarter
0121:                 len(surface.expiries) // 2,  # Middle
0122:                 -1  # Longest
0123:             ]
0124:         else:
0125:             expiry_indices = [expiry_idx]
0126:         
0127:         # Plot smile for each selected expiry
0128:         for idx in expiry_indices:
0129:             # Calculate moneyness for x-axis
0130:             moneyness = surface.strikes / surface.forward_prices[idx]
0131:             
0132:             fig.add_trace(go.Scatter(
0133:                 x=moneyness,
0134:                 y=surface.volatilities[:, idx],
0135:                 name=f'T = {surface.expiries[idx]:.2f}',
0136:                 mode='lines+markers',
0137:                 hovertemplate=(
0138:                     'Moneyness: %{x:.2f}<br>' +
0139:                     'IV: %{y:.1%}<br>' +
0140:                     'Strike: %{customdata[0]:.1f}'
0141:                 ),
0142:                 customdata=np.column_stack([surface.strikes])
0143:             ))
0144:         
0145:         # Add vertical line at ATM point
0146:         fig.add_vline(
0147:             x=1.0,
0148:             line_dash="dash",
0149:             line_color="gray",
0150:             annotation_text="ATM"
0151:         )
0152:         
0153:         # Update layout with explanatory elements
0154:         fig.update_layout(
0155:             title='Volatility Smile Analysis',
0156:             xaxis_title='Moneyness (K/F)',
0157:             yaxis_title='Implied Volatility',
0158:             width=self.config.width,
0159:             height=self.config.height,
0160:             template=self.config.template,
0161:             showlegend=True,
0162:             annotations=[
0163:                 dict(
0164:                     text="OTM Puts",
0165:                     xref="x", yref="paper",
0166:                     x=0.7, y=1.05,
0167:                     showarrow=False
0168:                 ),
0169:                 dict(
0170:                     text="OTM Calls",
0171:                     xref="x", yref="paper",
0172:                     x=1.3, y=1.05,
0173:                     showarrow=False
0174:                 )
0175:             ]
0176:         )
0177:         
0178:         return fig
0179:     
0180:     def plot_term_structure(self, surface: VolatilitySurface,
0181:                           moneyness_levels: Optional[List[float]] = None) -> go.Figure:
0182:         """
0183:         Create an interactive plot of the volatility term structure.
0184:         
0185:         This visualization shows:
0186:         1. How volatility varies with time to expiry
0187:         2. Term structure patterns at different moneyness levels
0188:         3. Mean reversion effects in longer-dated options
0189:         4. Impact of upcoming events on specific expiries
0190:         """
0191:         if moneyness_levels is None:
0192:             moneyness_levels = [0.9, 0.95, 1.0, 1.05, 1.10]
0193:         
0194:         fig = go.Figure()
0195:         
0196:         # Plot term structure for each moneyness level
0197:         for moneyness in moneyness_levels:
0198:             vols = []
0199:             for i, expiry in enumerate(surface.expiries):
0200:                 # Find strike closest to desired moneyness
0201:                 target_strike = surface.forward_prices[i] * moneyness
0202:                 strike_idx = np.abs(surface.strikes - target_strike).argmin()
0203:                 vols.append(surface.volatilities[strike_idx, i])
0204:             
0205:             fig.add_trace(go.Scatter(
0206:                 x=surface.expiries,
0207:                 y=vols,
0208:                 name=f'{moneyness:.0%} Moneyness',
0209:                 mode='lines+markers',
0210:                 hovertemplate=(
0211:                     'Expiry: %{x:.2f}<br>' +
0212:                     'IV: %{y:.1%}'
0213:                 )
0214:             ))
0215:         
0216:         # Update layout with explanatory elements
0217:         fig.update_layout(
0218:             title='Volatility Term Structure',
0219:             xaxis_title='Time to Expiry (Years)',
0220:             yaxis_title='Implied Volatility',
0221:             width=self.config.width,
0222:             height=self.config.height,
0223:             template=self.config.template,
0224:             showlegend=True,
0225:             annotations=[
0226:                 dict(
0227:                     text="Higher lines indicate more OTM options",
0228:                     xref="paper", yref="paper",
0229:                     x=1.02, y=0.95,
0230:                     showarrow=False
0231:                 )
0232:             ]
0233:         )
0234:         
0235:         return fig
0236: 
0237:     def create_greek_analysis_dashboard(self, results: List[OptionResult],
0238:                                       parameters: Dict[str, np.ndarray]) -> go.Figure:
0239:         """
0240:         Create a comprehensive dashboard for analyzing option Greeks.
0241:         
0242:         This dashboard shows:
0243:         1. How Greeks vary with underlying price
0244:         2. Relationships between different Greeks
0245:         3. Time decay effects
0246:         4. Risk exposures at different strikes
0247:         """
0248:         # Create subplot grid for different Greeks
0249:         fig = make_subplots(
0250:             rows=3, cols=2,
0251:             subplot_titles=(
0252:                 'Delta', 'Gamma',
0253:                 'Theta', 'Vega',
0254:                 'Rho', 'Greeks Relationships'
0255:             ),
0256:             specs=[[{}, {}],
0257:                   [{}, {}],
0258:                   [{}, {'type': 'scatter3d'}]]
0259:         )
0260:         
0261:         # Extract parameters
0262:         spot_prices = parameters['spot']
0263:         times = parameters['time']
0264:         
0265:         # Plot each Greek
0266:         for i, result in enumerate(results):
0267:             greeks = result.greeks
0268:             
0269:             # Delta plot
0270:             fig.add_trace(
0271:                 go.Scatter(
0272:                     x=spot_prices,
0273:                     y=[g['delta'] for g in greeks],
0274:                     name=f'Delta T={times[i]:.2f}'
0275:                 ),
0276:                 row=1, col=1
0277:             )
0278:             
0279:             # Similar traces for other Greeks...
0280:             # (Implementation continues with other Greeks)
0281:             
0282:             # 3D plot showing relationship between Delta, Gamma, and Spot
0283:             fig.add_trace(
0284:                 go.Scatter3d(
0285:                     x=[g['delta'] for g in greeks],
0286:                     y=[g['gamma'] for g in greeks],
0287:                     z=spot_prices,
0288:                     name=f'Delta-Gamma T={times[i]:.2f}'
0289:                 ),
0290:                 row=3, col=2
0291:             )
0292:         
0293:         # Update layout with educational annotations
0294:         fig.update_layout(
0295:             height=1200,  # Larger height for dashboard
0296:             width=self.config.width,
0297:             template=self.config.template,
0298:             showlegend=True,
0299:             annotations=[
0300:                 dict(
0301:                     text="Delta approaches 1 (calls) or -1 (puts) for deep ITM options",
0302:                     xref="paper", yref="paper",
0303:                     x=0.02, y=0.98,
0304:                     showarrow=False
0305:                 ),
0306:                 # Additional educational annotations...
0307:             ]
0308:         )
0309:         
0310:         return fig

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\analytics\volatility.py
// ----------------------------------------
0001: # src/analytics/volatility.py
0002: 
0003: import numpy as np
0004: from dataclasses import dataclass, field
0005: from typing import List, Optional, Dict
0006: from scipy.interpolate import interp2d
0007: from scipy.optimize import minimize
0008: import pandas as pd
0009: 
0010: from src.config import AppConfig
0011: from src.models.black_scholes import BlackScholesModel
0012: 
0013: 
0014: @dataclass
0015: class VolatilitySurface:
0016:     """Represents a volatility surface for option pricing."""
0017:     strikes: np.ndarray
0018:     expiries: np.ndarray
0019:     volatilities: np.ndarray
0020:     forward_prices: Optional[np.ndarray] = None
0021:     metadata: Dict = field(default_factory=dict)
0022: 
0023:     def __post_init__(self):
0024:         """
0025:         Initialize interpolation function and validate surface.
0026: 
0027:         This function checks for sufficient data points and creates a 2D
0028:         interpolation function that can be used to estimate volatility
0029:         at any given strike and expiry within the surface's range.
0030:         """
0031:         if self.strikes.shape[0] < 2 or self.expiries.shape[0] < 2:
0032:             raise ValueError("Insufficient data points for surface construction.")
0033:         self.interpolation_func = interp2d(
0034:             self.strikes,
0035:             self.expiries,
0036:             self.volatilities.T,
0037:             kind='cubic'
0038:         )
0039: 
0040:     def get_volatility(self, strike: float, expiry: float) -> float:
0041:         """
0042:         Get the interpolated volatility for a specific strike and expiry.
0043: 
0044:         Args:
0045:             strike: Strike price of the option
0046:             expiry: Time to expiry of the option in years
0047: 
0048:         Returns:
0049:             Interpolated volatility at the given strike and expiry
0050:         """
0051:         if not (self.strikes.min() <= strike <= self.strikes.max()):
0052:             raise ValueError(f"Strike {strike} is outside the valid range.")
0053:         if not (self.expiries.min() <= expiry <= self.expiries.max()):
0054:             raise ValueError(f"Expiry {expiry} is outside the valid range.")
0055:         return self.interpolation_func(strike, expiry)[0]
0056: 
0057:     def calibrate_to_market(self, market_prices: pd.DataFrame,
0058:                              model: 'OptionPricingModel',
0059:                              method: str = 'Nelder-Mead') -> None:
0060:         """
0061:         Calibrate the volatility surface to observed market prices.
0062: 
0063:         This function adjusts the volatility surface to minimize the difference
0064:         between model-predicted prices and market prices for a set of options.
0065:         It's particularly useful for ensuring the surface reflects current
0066:         market conditions.
0067: 
0068:         Args:
0069:             market_prices: DataFrame containing market prices of options with columns
0070:                            'strike', 'expiry', 'price'
0071:             model: Option pricing model instance used for calibration
0072:             method: Optimization method to use (from scipy.optimize.minimize)
0073:         """
0074:         def error_function(params):
0075:             """Error function to minimize."""
0076:             error = 0
0077:             k = 0
0078:             for _, row in market_prices.iterrows():
0079:                 strike_idx = np.abs(self.strikes - row['strike']).argmin()
0080:                 expiry_idx = np.abs(self.expiries - row['expiry']).argmin()
0081: 
0082:                 # Update volatility in the surface
0083:                 self.volatilities[strike_idx, expiry_idx] = params[k]
0084: 
0085:                 # Update interpolation function
0086:                 self.interpolation_func = interp2d(
0087:                     self.strikes,
0088:                     self.expiries,
0089:                     self.volatilities.T,
0090:                     kind='cubic'
0091:                 )
0092: 
0093:                 # Calculate model price with updated volatility
0094:                 model_price = model.price_option(
0095:                     S=model.S,
0096:                     K=row['strike'],
0097:                     r=model.r,
0098:                     sigma=self.get_volatility(row['strike'], row['expiry']),
0099:                     T=row['expiry'],
0100:                     option_type=row['option_type']
0101:                 ).price
0102: 
0103:                 error += (model_price - row['price'])**2
0104:                 k += 1
0105:             return np.sqrt(error / len(market_prices))  # RMSE
0106: 
0107:         # Initial parameters (current volatilities)
0108:         initial_params = self.volatilities.flatten()
0109: 
0110:         # Perform optimization
0111:         result = minimize(
0112:             error_function,
0113:             initial_params,
0114:             method=method,
0115:             bounds=[(0.01, 1.0) for _ in range(len(initial_params))]  # Volatility bounds
0116:         )
0117: 
0118:         if result.success:
0119:             # Update volatilities with optimized values
0120:             self.volatilities = result.x.reshape(self.volatilities.shape)
0121: 
0122:             # Rebuild interpolation function
0123:             self.interpolation_func = interp2d(
0124:                 self.strikes,
0125:                 self.expiries,
0126:                 self.volatilities.T,
0127:                 kind='cubic'
0128:             )
0129: 
0130:             print("Calibration successful.")
0131:         else:
0132:             print(f"Calibration failed: {result.message}")
0133: 
0134:     def visualize(self) -> None:
0135:         """Visualize the volatility surface."""
0136:         # Placeholder for visualization code
0137:         pass
0138: 
0139: class VolatilityAnalyzer:
0140:     """Analyzes and interprets volatility surfaces."""
0141: 
0142:     def __init__(self, pricing_model: 'OptionPricingModel'):
0143:         """
0144:         Initialize the Volatility Analyzer.
0145: 
0146:         Args:
0147:             pricing_model: An instance of an option pricing model
0148:         """
0149:         self.model = pricing_model
0150: 
0151:     def calculate_implied_volatility(self, option_price: float, strike: float,
0152:                                      expiry: float, option_type: str,
0153:                                      method: str = 'brentq') -> float:
0154:         """
0155:         Calculate the implied volatility of an option using numerical methods.
0156: 
0157:         Args:
0158:             option_price: Market price of the option
0159:             strike: Strike price of the option
0160:             expiry: Time to expiry of the option in years
0161:             option_type: Type of the option ('call' or 'put')
0162:         """
0163:         # Using the implied_volatility method of the BlackScholesModel
0164:         if option_type.lower() == "call":
0165:             iv = self.model.implied_volatility(option_price, self.model.S, strike, self.model.r, expiry, option_type)
0166:         elif option_type.lower() == "put":
0167:             iv = self.model.implied_volatility(option_price, self.model.S, strike, self.model.r, expiry, option_type)
0168:         else:
0169:             raise ValueError("Invalid option_type. Must be 'call' or 'put'")
0170: 
0171:         return iv

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\config.py
// ----------------------------------------
0001: # src/config.py
0002: from dataclasses import dataclass
0003: from typing import Dict, Optional
0004: 
0005: @dataclass
0006: class AppConfig:
0007:     """Application configuration parameters."""
0008:     default_model: str = "Black-Scholes"
0009:     monte_carlo_sims: int = 10000
0010:     binomial_steps: int = 100
0011:     plot_style: str = "dark"
0012:     cache_timeout: int = 3600  # seconds
0013:     
0014:     # Numerical parameters
0015:     epsilon: float = 1e-8
0016:     max_iterations: int = 1000
0017:     
0018:     # UI configuration
0019:     default_spot: float = 100.0
0020:     default_strike: float = 100.0
0021:     default_rate: float = 0.05
0022:     default_volatility: float = 0.2
0023:     default_maturity: float = 1.0

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\models\__init__.py
// ----------------------------------------

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\models\base.py
// ----------------------------------------
0001: # src/models/base.py
0002: from abc import ABC, abstractmethod
0003: from dataclasses import dataclass
0004: from typing import Dict, Optional, Tuple
0005: 
0006: @dataclass
0007: class OptionResult:
0008:     """Container for option pricing results."""
0009:     price: float
0010:     greeks: Optional[Dict[str, float]] = None
0011:     error_estimate: Optional[float] = None
0012:     additional_info: Optional[Dict[str, any]] = None
0013: 
0014: class OptionPricingModel(ABC):
0015:     """Abstract base class for option pricing models."""
0016:     
0017:     @abstractmethod
0018:     def price_call(self, S: float, K: float, r: float, sigma: float, T: float) -> OptionResult:
0019:         """Price a European call option."""
0020:         pass
0021:     
0022:     @abstractmethod
0023:     def price_put(self, S: float, K: float, r: float, sigma: float, T: float) -> OptionResult:
0024:         """Price a European put option."""
0025:         pass
0026:     
0027:     @abstractmethod
0028:     def calculate_greeks(self, S: float, K: float, r: float, sigma: float, T: float,
0029:                         option_type: str = "call") -> Dict[str, float]:
0030:         """Calculate option Greeks."""
0031:         pass
0032: 

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\models\binomial.py
// ----------------------------------------
0001: # src/models/binomial.py
0002: 
0003: import numpy as np
0004: from typing import Dict, Optional, Tuple
0005: from dataclasses import dataclass
0006: 
0007: from src.models.base import OptionPricingModel, OptionResult
0008: from src.utils.validation import validate_parameters
0009: from src.config import AppConfig
0010: 
0011: @dataclass
0012: class BinomialParameters:
0013:     """Parameters for the binomial tree model."""
0014:     dt: float      # Time step size
0015:     u: float       # Up factor
0016:     d: float       # Down factor
0017:     p: float       # Risk-neutral probability of up move
0018:     discount: float  # Discount factor per step
0019: 
0020: class BinomialModel(OptionPricingModel):
0021:     """
0022:     Cox-Ross-Rubinstein binomial tree model for option pricing.
0023:     
0024:     This implementation provides:
0025:     1. European and American option pricing
0026:     2. Early exercise boundary calculation
0027:     3. Implied tree calibration to market prices
0028:     4. Greeks calculation through finite differences
0029:     5. Dividend handling for discrete dividends
0030:     
0031:     The binomial model discretizes time and stock price movements, making it
0032:     particularly useful for understanding option pricing concepts and handling
0033:     early exercise features in American options.
0034:     """
0035:     
0036:     def __init__(self, n_steps: int = AppConfig.binomial_steps):
0037:         """Initialize the binomial model with the specified number of steps."""
0038:         self.n_steps = n_steps
0039:     
0040:     def _calculate_parameters(self, sigma: float, T: float, r: float) -> BinomialParameters:
0041:         """
0042:         Calculate the basic parameters of the binomial tree.
0043:         
0044:         The parameters are chosen to ensure the discrete model converges to
0045:         the continuous-time Black-Scholes model as the number of steps increases.
0046:         This means matching the first two moments of the price distribution.
0047:         """
0048:         dt = T / self.n_steps
0049:         
0050:         # Calculate up and down factors using the Cox-Ross-Rubinstein parameterization
0051:         u = np.exp(sigma * np.sqrt(dt))
0052:         d = 1 / u  # Ensures that u*d = 1
0053:         
0054:         # Calculate risk-neutral probability
0055:         # This ensures the expected return equals the risk-free rate
0056:         p = (np.exp(r * dt) - d) / (u - d)
0057:         
0058:         # Calculate per-step discount factor
0059:         discount = np.exp(-r * dt)
0060:         
0061:         return BinomialParameters(dt, u, d, p, discount)
0062:     
0063:     def _build_price_tree(self, S: float, params: BinomialParameters) -> np.ndarray:
0064:         """
0065:         Build the stock price tree using the binomial parameters.
0066:         
0067:         The tree is stored in a 2D array where element [i,j] represents the
0068:         stock price at time step i and up-move j. This structure allows for
0069:         efficient vectorized operations in option value calculations.
0070:         """
0071:         price_tree = np.zeros((self.n_steps + 1, self.n_steps + 1))
0072:         
0073:         # Initial stock price
0074:         price_tree[0, 0] = S
0075:         
0076:         # Build the tree level by level
0077:         for i in range(1, self.n_steps + 1):
0078:             # At each level i, we have i+1 possible prices
0079:             for j in range(i + 1):
0080:                 # Price = S * u^(number of ups) * d^(number of downs)
0081:                 price_tree[i, j] = S * (params.u ** (j)) * (params.d ** (i - j))
0082:         
0083:         return price_tree
0084:     
0085:     @validate_parameters
0086:     def price_european(self, S: float, K: float, r: float, sigma: float,
0087:                       T: float, option_type: str = "call") -> OptionResult:
0088:         """
0089:         Price a European option using the binomial model.
0090:         
0091:         The method proceeds in two steps:
0092:         1. Build the price tree forward from t=0 to t=T
0093:         2. Calculate option values backward from t=T to t=0
0094:         
0095:         This implementation is vectorized for better performance with
0096:         large numbers of steps.
0097:         """
0098:         params = self._calculate_parameters(sigma, T, r)
0099:         price_tree = self._build_price_tree(S, params)
0100:         
0101:         # Calculate terminal option values
0102:         option_values = np.zeros_like(price_tree)
0103:         if option_type.lower() == "call":
0104:             option_values[-1, :] = np.maximum(
0105:                 price_tree[-1, :] - K, 0
0106:             )
0107:         else:
0108:             option_values[-1, :] = np.maximum(
0109:                 K - price_tree[-1, :], 0
0110:             )
0111:         
0112:         # Backward induction
0113:         for i in range(self.n_steps - 1, -1, -1):
0114:             for j in range(i + 1):
0115:                 # Expected value of option at next time step
0116:                 option_values[i, j] = (
0117:                     params.p * option_values[i + 1, j + 1] +
0118:                     (1 - params.p) * option_values[i + 1, j]
0119:                 ) * params.discount
0120:         
0121:         # Calculate Greeks for the result
0122:         greeks = self.calculate_greeks(S, K, r, sigma, T, option_type)
0123:         
0124:         return OptionResult(
0125:             price=option_values[0, 0],
0126:             greeks=greeks,
0127:             additional_info={
0128:                 "n_steps": self.n_steps,
0129:                 "parameters": params
0130:             }
0131:         )
0132:     
0133:     @validate_parameters
0134:     def price_american(self, S: float, K: float, r: float, sigma: float,
0135:                       T: float, option_type: str = "call") -> OptionResult:
0136:         """
0137:         Price an American option using the binomial model.
0138:         
0139:         This method extends the European pricing by checking for optimal
0140:         early exercise at each node. It also tracks the early exercise
0141:         boundary, which can be useful for understanding optimal exercise
0142:         strategies.
0143:         """
0144:         params = self._calculate_parameters(sigma, T, r)
0145:         price_tree = self._build_price_tree(S, params)
0146:         
0147:         # Initialize arrays for values and exercise boundary
0148:         option_values = np.zeros_like(price_tree)
0149:         exercise_boundary = np.full(self.n_steps + 1, np.nan)
0150:         
0151:         # Set terminal payoffs
0152:         if option_type.lower() == "call":
0153:             option_values[-1, :] = np.maximum(
0154:                 price_tree[-1, :] - K, 0
0155:             )
0156:         else:
0157:             option_values[-1, :] = np.maximum(
0158:                 K - price_tree[-1, :], 0
0159:             )
0160:         
0161:         # Backward induction with early exercise
0162:         for i in range(self.n_steps - 1, -1, -1):
0163:             for j in range(i + 1):
0164:                 # Calculate continuation value
0165:                 continuation_value = (
0166:                     params.p * option_values[i + 1, j + 1] +
0167:                     (1 - params.p) * option_values[i + 1, j]
0168:                 ) * params.discount
0169:                 
0170:                 # Calculate immediate exercise value
0171:                 current_price = price_tree[i, j]
0172:                 if option_type.lower() == "call":
0173:                     exercise_value = max(current_price - K, 0)
0174:                 else:
0175:                     exercise_value = max(K - current_price, 0)
0176:                 
0177:                 # Option value is maximum of continuation and exercise
0178:                 option_values[i, j] = max(continuation_value, exercise_value)
0179:                 
0180:                 # Track exercise boundary
0181:                 if exercise_value > continuation_value:
0182:                     exercise_boundary[i] = current_price
0183:         
0184:         # Calculate Greeks
0185:         greeks = self.calculate_greeks(S, K, r, sigma, T, option_type)
0186:         
0187:         return OptionResult(
0188:             price=option_values[0, 0],
0189:             greeks=greeks,
0190:             additional_info={
0191:                 "n_steps": self.n_steps,
0192:                 "parameters": params,
0193:                 "exercise_boundary": exercise_boundary
0194:             }
0195:         )
0196:     
0197:     def calculate_greeks(self, S: float, K: float, r: float, sigma: float,
0198:                         T: float, option_type: str = "call") -> Dict[str, float]:
0199:         """
0200:         Calculate option Greeks using finite differences.
0201:         
0202:         While the binomial model can compute some Greeks directly from the tree,
0203:         we use finite differences for consistency with other models and to
0204:         handle both European and American options uniformly.
0205:         """
0206:         eps_S = S * 0.001  # Small change in stock price
0207:         eps_sigma = 0.001  # Small change in volatility
0208:         eps_r = 0.0001    # Small change in interest rate
0209:         eps_T = 1/365     # One day change in time
0210:         
0211:         # Select appropriate pricing function based on option type
0212:         price_func = self.price_american if option_type.lower() == "american" else self.price_european
0213:         
0214:         # Calculate base price
0215:         base_result = price_func(S, K, r, sigma, T, option_type)
0216:         base_price = base_result.price
0217:         
0218:         # Delta: ∂V/∂S (central difference)
0219:         price_up = price_func(S + eps_S, K, r, sigma, T, option_type).price
0220:         price_down = price_func(S - eps_S, K, r, sigma, T, option_type).price
0221:         delta = (price_up - price_down) / (2 * eps_S)
0222:         
0223:         # Gamma: ∂²V/∂S² (central difference)
0224:         gamma = (price_up - 2 * base_price + price_down) / (eps_S * eps_S)
0225:         
0226:         # Theta: -∂V/∂T (forward difference)
0227:         if T <= eps_T:
0228:             theta = 0  # At expiry
0229:         else:
0230:             price_later = price_func(S, K, r, sigma, T + eps_T, option_type).price
0231:             theta = -(price_later - base_price) / eps_T
0232:         
0233:         # Vega: ∂V/∂σ (central difference)
0234:         price_vol_up = price_func(S, K, r, sigma + eps_sigma, T, option_type).price
0235:         price_vol_down = price_func(S, K, r, sigma - eps_sigma, T, option_type).price
0236:         vega = (price_vol_up - price_vol_down) / (2 * eps_sigma)
0237:         
0238:         # Rho: ∂V/∂r (central difference)
0239:         price_r_up = price_func(S, K, r + eps_r, sigma, T, option_type).price
0240:         price_r_down = price_func(S, K, r - eps_r, sigma, T, option_type).price
0241:         rho = (price_r_up - price_r_down) / (2 * eps_r)
0242:         
0243:         return {
0244:             "delta": delta,
0245:             "gamma": gamma,
0246:             "theta": theta,
0247:             "vega": vega,
0248:             "rho": rho
0249:         }

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\models\black_scholes.py
// ----------------------------------------
0001: # src/models/black_scholes.py
0002: 
0003: import numpy as np
0004: from typing import Dict, Optional
0005: from dataclasses import dataclass
0006: import logging
0007: from scipy.stats import norm
0008: 
0009: from src.models.base import OptionPricingModel, OptionResult
0010: from src.utils.validation import validate_parameters
0011: from src.config import AppConfig
0012: 
0013: @dataclass
0014: class BlackScholesParameters:
0015:     """Parameters used in the Black-Scholes model."""
0016:     S: float      # Current stock price
0017:     K: float      # Strike price
0018:     r: float      # Risk-free interest rate
0019:     sigma: float  # Volatility of the underlying asset
0020:     T: float      # Time to maturity in years
0021:     q: float      # Dividend yield
0022: 
0023: class BlackScholesModel(OptionPricingModel):
0024:     """
0025:     Black-Scholes analytical model for European option pricing.
0026:     
0027:     This implementation provides:
0028:     1. Pricing for European call and put options.
0029:     2. Analytical calculation of Greeks: Delta, Gamma, Theta, Vega, and Rho.
0030:     3. Handling of dividend yields.
0031:     4. Robust parameter validation and error handling.
0032:     
0033:     The Black-Scholes model offers closed-form solutions for option prices and Greeks,
0034:     making it highly efficient for European-style options on non-dividend-paying or
0035:     dividend-paying assets.
0036:     """
0037:     
0038:     def __init__(self, 
0039:                  q: float = 0.0, 
0040:                  logging_enabled: bool = True):
0041:         """
0042:             Initialize the Black-Scholes model with optional dividend yield.
0043:             
0044:             Parameters:
0045:             - q: Dividend yield of the underlying asset (default is 0.0).
0046:             - logging_enabled: Enable or disable logging (default is True).
0047:         """
0048:         self.q = q
0049:         self.logger = logging.getLogger(__name__)
0050:         if logging_enabled:
0051:             self.logger.setLevel(logging.INFO)
0052:         else:
0053:             self.logger.setLevel(logging.WARNING)
0054:     
0055:     @validate_parameters
0056:     def price_call(self, S: float, K: float, r: float, sigma: float, T: float,
0057:                    q: Optional[float] = None) -> OptionResult:
0058:         """
0059:         Price a European call option using the Black-Scholes formula.
0060:         
0061:         Parameters:
0062:         - S: Current stock price
0063:         - K: Strike price
0064:         - r: Risk-free interest rate
0065:         - sigma: Volatility of the underlying asset
0066:         - T: Time to maturity in years
0067:         - q: Dividend yield (optional, defaults to model's q)
0068:         
0069:         Returns:
0070:         - OptionResult containing the price, Greeks, and additional information.
0071:         """
0072:         q = self.q if q is None else q
0073:         params = BlackScholesParameters(S, K, r, sigma, T, q)
0074:         self.logger.info(f"Pricing European Call with parameters: {params}")
0075:         
0076:         d1, d2 = self._calculate_d1_d2(params)
0077:         call_price = (S * np.exp(-q * T) * norm.cdf(d1)) - (K * np.exp(-r * T) * norm.cdf(d2))
0078:         
0079:         greeks = self._calculate_greeks(d1, d2, params)
0080:         
0081:         return OptionResult(
0082:             price=call_price,
0083:             greeks=greeks,
0084:             error_estimate=None,  # Analytical model has no simulation error
0085:             additional_info={
0086:                 "model": "Black-Scholes",
0087:                 "parameters": params
0088:             }
0089:         )
0090:     
0091:     @validate_parameters
0092:     def price_put(self, S: float, K: float, r: float, sigma: float, T: float,
0093:                  q: Optional[float] = None) -> OptionResult:
0094:         """
0095:         Price a European put option using the Black-Scholes formula.
0096:         
0097:         Parameters:
0098:         - S: Current stock price
0099:         - K: Strike price
0100:         - r: Risk-free interest rate
0101:         - sigma: Volatility of the underlying asset
0102:         - T: Time to maturity in years
0103:         - q: Dividend yield (optional, defaults to model's q)
0104:         
0105:         Returns:
0106:         - OptionResult containing the price, Greeks, and additional information.
0107:         """
0108:         q = self.q if q is None else q
0109:         params = BlackScholesParameters(S, K, r, sigma, T, q)
0110:         self.logger.info(f"Pricing European Put with parameters: {params}")
0111:         
0112:         d1, d2 = self._calculate_d1_d2(params)
0113:         put_price = (K * np.exp(-r * T) * norm.cdf(-d2)) - (S * np.exp(-q * T) * norm.cdf(-d1))
0114:         
0115:         greeks = self._calculate_greeks(d1, d2, params)
0116:         
0117:         return OptionResult(
0118:             price=put_price,
0119:             greeks=greeks,
0120:             error_estimate=None,  # Analytical model has no simulation error
0121:             additional_info={
0122:                 "model": "Black-Scholes",
0123:                 "parameters": params
0124:             }
0125:         )
0126:     
0127:     def _calculate_d1_d2(self, params: BlackScholesParameters) -> Tuple[float, float]:
0128:         """
0129:         Calculate the d1 and d2 parameters used in the Black-Scholes formula.
0130:         
0131:         Parameters:
0132:         - params: BlackScholesParameters dataclass instance.
0133:         
0134:         Returns:
0135:         - A tuple containing d1 and d2.
0136:         """
0137:         if params.T <= 0:
0138:             raise ValueError("Time to maturity must be positive.")
0139:         
0140:         d1 = (np.log(params.S / params.K) + (params.r - params.q + 0.5 * params.sigma**2) * params.T) / \
0141:              (params.sigma * np.sqrt(params.T))
0142:         d2 = d1 - params.sigma * np.sqrt(params.T)
0143:         
0144:         self.logger.debug(f"Calculated d1: {d1}, d2: {d2}")
0145:         return d1, d2
0146:     
0147:     def _calculate_greeks(self, d1: float, d2: float, params: BlackScholesParameters) -> Dict[str, float]:
0148:         """
0149:         Calculate the Greeks for the option.
0150:         
0151:         Parameters:
0152:         - d1: Calculated d1 from Black-Scholes formula
0153:         - d2: Calculated d2 from Black-Scholes formula
0154:         - params: BlackScholesParameters dataclass instance.
0155:         
0156:         Returns:
0157:         - Dictionary containing Delta, Gamma, Theta, Vega, and Rho.
0158:         """
0159:         delta = np.exp(-params.q * params.T) * norm.cdf(d1) if params.option_type == "call" else \
0160:                 np.exp(-params.q * params.T) * (norm.cdf(d1) - 1)
0161:         gamma = (np.exp(-params.q * params.T) * norm.pdf(d1)) / (params.S * params.sigma * np.sqrt(params.T))
0162:         theta_call = (- (params.S * params.sigma * np.exp(-params.q * params.T) * norm.pdf(d1)) / (2 * np.sqrt(params.T)) 
0163:                       - params.q * params.S * np.exp(-params.q * params.T) * norm.cdf(d1) 
0164:                       + params.q * params.K * np.exp(-params.r * params.T) * norm.cdf(d2))
0165:         theta_put = (- (params.S * params.sigma * np.exp(-params.q * params.T) * norm.pdf(d1)) / (2 * np.sqrt(params.T)) 
0166:                      + params.q * params.S * np.exp(-params.q * params.T) * norm.cdf(-d1) 
0167:                      - params.r * params.K * np.exp(-params.r * params.T) * norm.cdf(-d2))
0168:         vega = params.S * np.exp(-params.q * params.T) * norm.pdf(d1) * np.sqrt(params.T)
0169:         rho_call = params.K * params.T * np.exp(-params.r * params.T) * norm.cdf(d2)
0170:         rho_put = -params.K * params.T * np.exp(-params.r * params.T) * norm.cdf(-d2)
0171:         
0172:         greeks = {
0173:             "delta": self._calculate_delta(params.option_type, d1, params),
0174:             "gamma": gamma,
0175:             "theta": self._calculate_theta(params.option_type, params, d1, d2),
0176:             "vega": vega,
0177:             "rho": self._calculate_rho(params.option_type, params, d2)
0178:         }
0179:         
0180:         self.logger.debug(f"Calculated Greeks: {greeks}")
0181:         return greeks
0182:     
0183:     def _calculate_delta(self, option_type: str, d1: float, params: BlackScholesParameters) -> float:
0184:         """
0185:         Calculate Delta for the option.
0186:         
0187:         Parameters:
0188:         - option_type: 'call' or 'put'
0189:         - d1: Calculated d1 from Black-Scholes formula
0190:         - params: BlackScholesParameters dataclass instance.
0191:         
0192:         Returns:
0193:         - Delta value.
0194:         """
0195:         if option_type.lower() == "call":
0196:             delta = np.exp(-params.q * params.T) * norm.cdf(d1)
0197:         else:
0198:             delta = np.exp(-params.q * params.T) * (norm.cdf(d1) - 1)
0199:         self.logger.debug(f"Calculated Delta: {delta}")
0200:         return delta
0201:     
0202:     def _calculate_theta(self, option_type: str, params: BlackScholesParameters, d1: float, d2: float) -> float:
0203:         """
0204:         Calculate Theta for the option.
0205:         
0206:         Parameters:
0207:         - option_type: 'call' or 'put'
0208:         - params: BlackScholesParameters dataclass instance.
0209:         - d1: Calculated d1 from Black-Scholes formula
0210:         - d2: Calculated d2 from Black-Scholes formula
0211:         
0212:         Returns:
0213:         - Theta value.
0214:         """
0215:         term1 = -(params.S * params.sigma * np.exp(-params.q * params.T) * norm.pdf(d1)) / (2 * np.sqrt(params.T))
0216:         if option_type.lower() == "call":
0217:             term2 = -params.q * params.S * np.exp(-params.q * params.T) * norm.cdf(d1)
0218:             term3 = params.q * params.K * np.exp(-params.r * params.T) * norm.cdf(d2)
0219:             theta = term1 + term2 + term3
0220:         else:
0221:             term2 = params.q * params.S * np.exp(-params.q * params.T) * norm.cdf(-d1)
0222:             term3 = -params.r * params.K * np.exp(-params.r * params.T) * norm.cdf(-d2)
0223:             theta = term1 + term2 + term3
0224:         self.logger.debug(f"Calculated Theta: {theta}")
0225:         return theta
0226:     
0227:     def _calculate_rho(self, option_type: str, params: BlackScholesParameters, d2: float) -> float:
0228:         """
0229:         Calculate Rho for the option.
0230:         
0231:         Parameters:
0232:         - option_type: 'call' or 'put'
0233:         - params: BlackScholesParameters dataclass instance.
0234:         - d2: Calculated d2 from Black-Scholes formula
0235:         
0236:         Returns:
0237:         - Rho value.
0238:         """
0239:         if option_type.lower() == "call":
0240:             rho = params.K * params.T * np.exp(-params.r * params.T) * norm.cdf(d2)
0241:         else:
0242:             rho = -params.K * params.T * np.exp(-params.r * params.T) * norm.cdf(-d2)
0243:         self.logger.debug(f"Calculated Rho: {rho}")
0244:         return rho
0245:     
0246:     def _calculate_vega(self, params: BlackScholesParameters, d1: float) -> float:
0247:         """
0248:         Calculate Vega for the option.
0249:         
0250:         Parameters:
0251:         - params: BlackScholesParameters dataclass instance.
0252:         - d1: Calculated d1 from Black-Scholes formula
0253:         
0254:         Returns:
0255:         - Vega value.
0256:         """
0257:         vega = params.S * np.exp(-params.q * params.T) * norm.pdf(d1) * np.sqrt(params.T)
0258:         self.logger.debug(f"Calculated Vega: {vega}")
0259:         return vega
0260:     
0261:     def calculate_greeks(self, S: float, K: float, r: float, sigma: float,
0262:                         T: float, option_type: str = "call",
0263:                         q: Optional[float] = None) -> Dict[str, float]:
0264:         """
0265:         Calculate option Greeks analytically.
0266:         
0267:         Parameters:
0268:         - S: Current stock price
0269:         - K: Strike price
0270:         - r: Risk-free interest rate
0271:         - sigma: Volatility of the underlying asset
0272:         - T: Time to maturity in years
0273:         - option_type: 'call' or 'put'
0274:         - q: Dividend yield (optional, defaults to model's q)
0275:         
0276:         Returns:
0277:         - Dictionary containing Delta, Gamma, Theta, Vega, and Rho.
0278:         """
0279:         q = self.q if q is None else q
0280:         params = BlackScholesParameters(S, K, r, sigma, T, q)
0281:         d1, d2 = self._calculate_d1_d2(params)
0282:         greeks = self._calculate_greeks(d1, d2, params)
0283:         return greeks
0284:     
0285:     @validate_parameters
0286:     def implied_volatility(self, option_price: float, S: float, K: float, r: float, T: float,
0287:                            option_type: str = "call", q: Optional[float] = None,
0288:                            initial_guess: float = 0.2, tol: float = 1e-6,
0289:                            max_iterations: int = 100) -> Optional[float]:
0290:         """
0291:         Calculate the implied volatility using the Black-Scholes model via the Newton-Raphson method.
0292:         
0293:         Parameters:
0294:         - option_price: Observed market price of the option
0295:         - S: Current stock price
0296:         - K: Strike price
0297:         - r: Risk-free interest rate
0298:         - T: Time to maturity in years
0299:         - option_type: 'call' or 'put'
0300:         - q: Dividend yield (optional, defaults to model's q)
0301:         - initial_guess: Initial guess for volatility (default is 0.2)
0302:         - tol: Tolerance for convergence (default is 1e-6)
0303:         - max_iterations: Maximum number of iterations (default is 100)
0304:         
0305:         Returns:
0306:         - Implied volatility if converged, else None.
0307:         """
0308:         q = self.q if q is None else q
0309:         sigma = initial_guess
0310:         for i in range(max_iterations):
0311:             params = BlackScholesParameters(S, K, r, sigma, T, q)
0312:             try:
0313:                 if option_type.lower() == "call":
0314:                     model_price = self.price_call(S, K, r, sigma, T, q).price
0315:                 else:
0316:                     model_price = self.price_put(S, K, r, sigma, T, q).price
0317:             except Exception as e:
0318:                 self.logger.error(f"Error in pricing during implied volatility calculation: {e}")
0319:                 return None
0320:             
0321:             # Vega for Newton-Raphson
0322:             d1, _ = self._calculate_d1_d2(params)
0323:             vega = self._calculate_vega(params, d1)
0324:             
0325:             price_diff = model_price - option_price
0326:             self.logger.debug(f"Iteration {i}: sigma={sigma}, price_diff={price_diff}, vega={vega}")
0327:             
0328:             if abs(price_diff) < tol:
0329:                 self.logger.info(f"Converged to implied volatility: {sigma} in {i} iterations.")
0330:                 return sigma
0331:             
0332:             if vega == 0:
0333:                 self.logger.warning("Vega is zero. Cannot continue Newton-Raphson.")
0334:                 return None
0335:             
0336:             sigma -= price_diff / vega
0337:         
0338:         self.logger.warning("Implied volatility did not converge.")
0339:         return None
0340:     
0341:     @validate_parameters
0342:     def price_option(self, S: float, K: float, r: float, sigma: float, T: float,
0343:                     option_type: str = "call", q: Optional[float] = None) -> OptionResult:
0344:         """
0345:         General method to price an option based on the option type.
0346:         
0347:         Parameters:
0348:         - S: Current stock price
0349:         - K: Strike price
0350:         - r: Risk-free interest rate
0351:         - sigma: Volatility of the underlying asset
0352:         - T: Time to maturity in years
0353:         - option_type: 'call' or 'put'
0354:         - q: Dividend yield (optional, defaults to model's q)
0355:         
0356:         Returns:
0357:         - OptionResult containing the price, Greeks, and additional information.
0358:         """
0359:         option_type = option_type.lower()
0360:         if option_type == "call":
0361:             return self.price_call(S, K, r, sigma, T, q)
0362:         elif option_type == "put":
0363:             return self.price_put(S, K, r, sigma, T, q)
0364:         else:
0365:             raise ValueError("option_type must be 'call' or 'put'")

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\models\monte_carlo.py
// ----------------------------------------
0001: # src/models/monte_carlo.py
0002: 
0003: import numpy as np
0004: from typing import Dict, List, Optional, Tuple
0005: from dataclasses import dataclass
0006: from concurrent.futures import ProcessPoolExecutor
0007: import logging
0008: 
0009: from src.models.base import OptionPricingModel, OptionResult
0010: from src.utils.validation import validate_parameters
0011: from src.config import AppConfig
0012: 
0013: @dataclass
0014: class SimulationResult:
0015:     """Contains the results of a Monte Carlo simulation run."""
0016:     paths: np.ndarray  # Shape: (n_sims, n_steps + 1)
0017:     final_prices: np.ndarray  # Shape: (n_sims,)
0018:     payoffs: np.ndarray  # Shape: (n_sims,)
0019:     confidence_interval: Tuple[float, float]
0020:     standard_error: float
0021: 
0022: class MonteCarloModel(OptionPricingModel):
0023:     """
0024:     Advanced Monte Carlo simulation for option pricing with variance reduction techniques.
0025:     
0026:     This implementation includes several sophisticated features:
0027:     1. Antithetic variates for variance reduction
0028:     2. Control variates using analytical solutions when available
0029:     3. Parallel processing for large simulations
0030:     4. Stratified sampling for better coverage of the probability space
0031:     5. Confidence interval estimation
0032:     """
0033:     
0034:     def __init__(self, n_sims: int = AppConfig.monte_carlo_sims, 
0035:                  n_steps: int = 252, random_seed: Optional[int] = None,
0036:                  n_processes: int = 4):
0037:         """
0038:         Initialize the Monte Carlo simulator with configurable parameters.
0039:         
0040:         The number of steps defaults to 252 (typical trading days in a year)
0041:         to provide realistic time discretization for path-dependent options.
0042:         """
0043:         self.n_sims = n_sims
0044:         self.n_steps = n_steps
0045:         self.n_processes = n_processes
0046:         if random_seed is not None:
0047:             np.random.seed(random_seed)
0048:         
0049:         # Initialize logging
0050:         self.logger = logging.getLogger(__name__)
0051:         self.logger.setLevel(logging.INFO)
0052:     
0053:     def _generate_paths(self, S: float, r: float, sigma: float, T: float,
0054:                        antithetic: bool = True) -> np.ndarray:
0055:         """
0056:         Generate stock price paths using geometric Brownian motion.
0057:         
0058:         The method uses antithetic variates by default to reduce variance:
0059:         for each random path, we also generate its negative counterpart.
0060:         This ensures better estimation of the expected value.
0061:         """
0062:         dt = T / self.n_steps
0063:         nudt = (r - 0.5 * sigma**2) * dt
0064:         sigmadt = sigma * np.sqrt(dt)
0065:         
0066:         # Generate standard normal random numbers
0067:         if antithetic:
0068:             Z = np.random.standard_normal((self.n_sims // 2, self.n_steps))
0069:             Z = np.concatenate([Z, -Z])  # Antithetic pairs
0070:         else:
0071:             Z = np.random.standard_normal((self.n_sims, self.n_steps))
0072:         
0073:         # Initialize paths array and set initial stock price
0074:         paths = np.zeros((self.n_sims, self.n_steps + 1))
0075:         paths[:, 0] = S
0076:         
0077:         # Generate paths using vectorized operations
0078:         for t in range(1, self.n_steps + 1):
0079:             paths[:, t] = paths[:, t-1] * np.exp(nudt + sigmadt * Z[:, t-1])
0080:         
0081:         return paths
0082:     
0083:     def _run_parallel_simulation(self, S: float, r: float, sigma: float, T: float,
0084:                                chunk_size: Optional[int] = None) -> List[np.ndarray]:
0085:         """
0086:         Run Monte Carlo simulations in parallel for better performance.
0087:         
0088:         This method splits the total number of simulations into chunks
0089:         that can be processed independently on different CPU cores.
0090:         """
0091:         if chunk_size is None:
0092:             chunk_size = self.n_sims // self.n_processes
0093:         
0094:         chunks = []
0095:         with ProcessPoolExecutor(max_workers=self.n_processes) as executor:
0096:             futures = []
0097:             for _ in range(self.n_processes):
0098:                 future = executor.submit(
0099:                     self._generate_paths,
0100:                     S, r, sigma, T,
0101:                     chunk_size
0102:                 )
0103:                 futures.append(future)
0104:             
0105:             # Collect results as they complete
0106:             for future in futures:
0107:                 chunk = future.result()
0108:                 chunks.append(chunk)
0109:         
0110:         return chunks
0111:     
0112:     @validate_parameters
0113:     def price_call(self, S: float, K: float, r: float, sigma: float, T: float,
0114:                    use_control_variate: bool = True) -> OptionResult:
0115:         """
0116:         Price a European call option using Monte Carlo simulation.
0117:         
0118:         When use_control_variate is True, the method uses the analytical
0119:         Black-Scholes price as a control variate to reduce variance.
0120:         """
0121:         # Generate price paths
0122:         paths = self._generate_paths(S, r, sigma, T)
0123:         final_prices = paths[:, -1]
0124:         
0125:         # Calculate payoffs
0126:         payoffs = np.maximum(final_prices - K, 0)
0127:         
0128:         # Apply control variate if requested
0129:         if use_control_variate and T > 0:
0130:             # Use stock price as control variate
0131:             control_payoffs = final_prices - S * np.exp(r * T)
0132:             beta = np.cov(payoffs, control_payoffs)[0, 1] / np.var(control_payoffs)
0133:             payoffs_adjusted = payoffs - beta * control_payoffs
0134:             
0135:             # Calculate the mean and standard error
0136:             price = np.exp(-r * T) * np.mean(payoffs_adjusted)
0137:             std_error = np.exp(-r * T) * np.std(payoffs_adjusted) / np.sqrt(self.n_sims)
0138:         else:
0139:             # Standard Monte Carlo estimation
0140:             price = np.exp(-r * T) * np.mean(payoffs)
0141:             std_error = np.exp(-r * T) * np.std(payoffs) / np.sqrt(self.n_sims)
0142:         
0143:         # Calculate confidence interval
0144:         conf_interval = (
0145:             price - 1.96 * std_error,
0146:             price + 1.96 * std_error
0147:         )
0148:         
0149:         return OptionResult(
0150:             price=price,
0151:             greeks=self.calculate_greeks(S, K, r, sigma, T, "call"),
0152:             error_estimate=std_error,
0153:             additional_info={
0154:                 "confidence_interval": conf_interval,
0155:                 "n_sims": self.n_sims,
0156:                 "n_steps": self.n_steps
0157:             }
0158:         )
0159:     
0160:     @validate_parameters
0161:     def price_put(self, S: float, K: float, r: float, sigma: float, T: float,
0162:                   use_control_variate: bool = True) -> OptionResult:
0163:         """
0164:         Price a European put option using Monte Carlo simulation.
0165:         
0166:         The implementation mirrors the call option pricing but with
0167:         adjusted payoff calculations for puts.
0168:         """
0169:         paths = self._generate_paths(S, r, sigma, T)
0170:         final_prices = paths[:, -1]
0171:         payoffs = np.maximum(K - final_prices, 0)
0172:         
0173:         if use_control_variate and T > 0:
0174:             control_payoffs = S * np.exp(r * T) - final_prices
0175:             beta = np.cov(payoffs, control_payoffs)[0, 1] / np.var(control_payoffs)
0176:             payoffs_adjusted = payoffs - beta * control_payoffs
0177:             
0178:             price = np.exp(-r * T) * np.mean(payoffs_adjusted)
0179:             std_error = np.exp(-r * T) * np.std(payoffs_adjusted) / np.sqrt(self.n_sims)
0180:         else:
0181:             price = np.exp(-r * T) * np.mean(payoffs)
0182:             std_error = np.exp(-r * T) * np.std(payoffs) / np.sqrt(self.n_sims)
0183:         
0184:         conf_interval = (
0185:             price - 1.96 * std_error,
0186:             price + 1.96 * std_error
0187:         )
0188:         
0189:         return OptionResult(
0190:             price=price,
0191:             greeks=self.calculate_greeks(S, K, r, sigma, T, "put"),
0192:             error_estimate=std_error,
0193:             additional_info={
0194:                 "confidence_interval": conf_interval,
0195:                 "n_sims": self.n_sims,
0196:                 "n_steps": self.n_steps
0197:             }
0198:         )
0199:     
0200:     def calculate_greeks(self, S: float, K: float, r: float, sigma: float,
0201:                         T: float, option_type: str = "call") -> Dict[str, float]:
0202:         """
0203:         Calculate option Greeks using finite difference methods.
0204:         
0205:         This implementation uses:
0206:         - Central differences for better accuracy in most Greeks
0207:         - Forward differences for Theta to handle time-to-maturity edge cases
0208:         - Multiple simulations with common random numbers to reduce variance
0209:         
0210:         While less precise than analytical solutions, this method works for
0211:         any payoff structure, making it valuable for exotic options.
0212:         """
0213:         # Small parameter changes for finite differences
0214:         eps_S = S * 0.001  # 0.1% of spot price
0215:         eps_sigma = 0.001  # 10 basis points of volatility
0216:         eps_r = 0.0001    # 1 basis point of rates
0217:         eps_T = 1/365.0   # One day
0218:         
0219:         # Store original random state to use same random numbers
0220:         random_state = np.random.get_state()
0221:         
0222:         # Price function based on option type
0223:         price_func = self.price_call if option_type.lower() == "call" else self.price_put
0224:         
0225:         # Delta: ∂V/∂S (central difference)
0226:         price_up = price_func(S + eps_S, K, r, sigma, T).price
0227:         price_down = price_func(S - eps_S, K, r, sigma, T).price
0228:         delta = (price_up - price_down) / (2 * eps_S)
0229:         
0230:         # Gamma: ∂²V/∂S² (central difference)
0231:         gamma = (price_up - 2 * price_func(S, K, r, sigma, T).price + price_down) / (eps_S * eps_S)
0232:         
0233:         # Theta: -∂V/∂T (forward difference)
0234:         if T <= eps_T:
0235:             # Special handling for very short time to maturity
0236:             price_up_T = price_func(S, K, r, sigma, 2 * eps_T).price
0237:             base_price = price_func(S, K, r, sigma, eps_T).price
0238:             theta = -(price_up_T - base_price) / eps_T
0239:         else:
0240:             price_up_T = price_func(S, K, r, sigma, T + eps_T).price
0241:             base_price = price_func(S, K, r, sigma, T).price
0242:             theta = -(price_up_T - base_price) / eps_T
0243:         
0244:         # Vega: ∂V/∂σ (central difference)
0245:         price_up_sig = price_func(S, K, r, sigma + eps_sigma, T).price
0246:         price_down_sig = price_func(S, K, r, sigma - eps_sigma, T).price
0247:         vega = (price_up_sig - price_down_sig) / (2 * eps_sigma)
0248:         
0249:         # Rho: ∂V/∂r (central difference)
0250:         price_up_r = price_func(S, K, r + eps_r, sigma, T).price
0251:         price_down_r = price_func(S, K, r - eps_r, sigma, T).price
0252:         rho = (price_up_r - price_down_r) / (2 * eps_r)
0253:         
0254:         # Restore original random state
0255:         np.random.set_state(random_state)
0256:         
0257:         return {
0258:             "delta": delta,
0259:             "gamma": gamma,
0260:             "theta": theta,
0261:             "vega": vega,
0262:             "rho": rho
0263:         }
0264:     
0265:     def price_exotic_option(self, S: float, K: float, r: float, sigma: float,
0266:                           T: float, payoff_func: callable,
0267:                           barrier: Optional[float] = None) -> OptionResult:
0268:         """
0269:         Price exotic options using Monte Carlo simulation.
0270:         
0271:         This method allows pricing of path-dependent options by accepting
0272:         a custom payoff function that can access the entire price path.
0273:         It's particularly useful for:
0274:         - Barrier options
0275:         - Asian options
0276:         - Lookback options
0277:         - Other exotic structures
0278:         """
0279:         # Generate price paths
0280:         paths = self._generate_paths(S, r, sigma, T)
0281:         
0282:         # Calculate payoffs using the provided payoff function
0283:         payoffs = payoff_func(paths)
0284:         
0285:         # Calculate price and error estimates
0286:         price = np.exp(-r * T) * np.mean(payoffs)
0287:         std_error = np.exp(-r * T) * np.std(payoffs) / np.sqrt(self.n_sims)
0288:         
0289:         # Calculate confidence interval
0290:         conf_interval = (
0291:             price - 1.96 * std_error,
0292:             price + 1.96 * std_error
0293:         )
0294:         
0295:         return OptionResult(
0296:             price=price,
0297:             error_estimate=std_error,
0298:             additional_info={
0299:                 "confidence_interval": conf_interval,
0300:                 "n_sims": self.n_sims,
0301:                 "paths_shape": paths.shape
0302:             }
0303:         )

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\__init__.py
// ----------------------------------------

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\components\__init__.py
// ----------------------------------------

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\components\charts.py
// ----------------------------------------
0001: # src/ui/components/charts.py
0002: 
0003: import plotly.graph_objects as go
0004: from plotly.subplots import make_subplots
0005: import numpy as np
0006: from typing import List, Optional
0007: from src.analytics.risk import Position # Relative import (still works within the same package)
0008: 
0009: class OptionPayoffChart:
0010:     """Component for displaying option payoff and risk profiles."""
0011:     
0012:     @staticmethod
0013:     def create_payoff_chart(positions: List[Position], price_range: Optional[np.ndarray] = None) -> go.Figure:
0014:         """Create an interactive payoff diagram for multiple positions."""
0015:         if not positions:
0016:             raise ValueError("No positions provided for payoff chart")
0017:         
0018:         # Determine price range if not provided
0019:         if price_range is None:
0020:             current_price = positions[0].underlying_price
0021:             price_range = np.linspace(current_price * 0.5, current_price * 1.5, 100)
0022:         
0023:         fig = go.Figure()
0024:         
0025:         # Calculate and plot individual position payoffs
0026:         total_payoff = np.zeros_like(price_range)
0027:         for pos in positions:
0028:             payoff = OptionPayoffChart._calculate_position_payoff(pos, price_range)
0029:             total_payoff += payoff
0030:             
0031:             fig.add_trace(go.Scatter(
0032:                 x=price_range,
0033:                 y=payoff,
0034:                 name=f"{pos.option_type.title()} K={pos.strike}",
0035:                 line=dict(dash='dash'),
0036:                 opacity=0.6
0037:             ))
0038:         
0039:         # Add total payoff line
0040:         fig.add_trace(go.Scatter(
0041:             x=price_range,
0042:             y=total_payoff,
0043:             name="Total Payoff",
0044:             line=dict(color='black', width=2)
0045:         ))
0046:         
0047:         # Add current price marker
0048:         current_price = positions[0].underlying_price
0049:         fig.add_vline(
0050:             x=current_price,
0051:             line_dash="dash",
0052:             line_color="gray",
0053:             annotation_text="Current Price"
0054:         )
0055:         
0056:         fig.update_layout(
0057:             title="Position Payoff Analysis",
0058:             xaxis_title="Underlying Price",
0059:             yaxis_title="Profit/Loss",
0060:             showlegend=True,
0061:             hovermode='x unified'
0062:         )
0063:         
0064:         return fig
0065: 
0066:     @staticmethod
0067:     def _calculate_position_payoff(position: Position, prices: np.ndarray) -> np.ndarray:
0068:         """Calculate payoff for a single position across price range."""
0069:         if position.option_type.lower() == "call":
0070:             payoff = np.maximum(prices - position.strike, 0)
0071:         else:
0072:             payoff = np.maximum(position.strike - prices, 0)
0073:         
0074:         return payoff * position.quantity * position.multiplier

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\components\option_inputs.py
// ----------------------------------------
0001: # src/ui/components/option_inputs.py
0002: 
0003: import streamlit as st
0004: from typing import Dict, Optional
0005: from dataclasses import dataclass
0006: 
0007: @dataclass
0008: class OptionParameters:
0009:     """Container for option parameters from UI inputs."""
0010:     underlying_price: float
0011:     strike_price: float
0012:     time_to_expiry: float
0013:     volatility: float
0014:     risk_free_rate: float
0015:     option_type: str
0016: 
0017: class OptionInputs:
0018:     """Reusable component for option parameter inputs."""
0019:     
0020:     def __init__(self, key_prefix: str = "", default_values: Optional[Dict] = None):
0021:         """Initialize with optional key prefix for multiple instances."""
0022:         self.key_prefix = key_prefix
0023:         self.default_values = default_values or {
0024:             "underlying_price": 100.0,
0025:             "strike_price": 100.0,
0026:             "time_to_expiry": 1.0,
0027:             "volatility": 0.2,
0028:             "risk_free_rate": 0.05
0029:         }
0030: 
0031:     def render(self) -> OptionParameters:
0032:         """Render option parameter inputs and return collected values."""
0033:         col1, col2 = st.columns(2)
0034:         
0035:         with col1:
0036:             underlying_price = st.number_input(
0037:                 "Underlying Price",
0038:                 min_value=0.01,
0039:                 value=self.default_values["underlying_price"],
0040:                 step=1.0,
0041:                 key=f"{self.key_prefix}underlying"
0042:             )
0043:             
0044:             strike_price = st.number_input(
0045:                 "Strike Price",
0046:                 min_value=0.01,
0047:                 value=self.default_values["strike_price"],
0048:                 step=1.0,
0049:                 key=f"{self.key_prefix}strike"
0050:             )
0051:             
0052:             time_to_expiry = st.slider(
0053:                 "Time to Expiry (Years)",
0054:                 min_value=0.1,
0055:                 max_value=5.0,
0056:                 value=self.default_values["time_to_expiry"],
0057:                 step=0.1,
0058:                 key=f"{self.key_prefix}expiry"
0059:             )
0060:         
0061:         with col2:
0062:             volatility = st.slider(
0063:                 "Volatility",
0064:                 min_value=0.05,
0065:                 max_value=1.0,
0066:                 value=self.default_values["volatility"],
0067:                 step=0.05,
0068:                 key=f"{self.key_prefix}volatility"
0069:             )
0070:             
0071:             risk_free_rate = st.slider(
0072:                 "Risk-free Rate",
0073:                 min_value=0.0,
0074:                 max_value=0.1,
0075:                 value=self.default_values["risk_free_rate"],
0076:                 step=0.01,
0077:                 key=f"{self.key_prefix}rate"
0078:             )
0079:             
0080:             option_type = st.selectbox(
0081:                 "Option Type",
0082:                 ["Call", "Put"],
0083:                 key=f"{self.key_prefix}type"
0084:             )
0085:         
0086:         return OptionParameters(
0087:             underlying_price=underlying_price,
0088:             strike_price=strike_price,
0089:             time_to_expiry=time_to_expiry,
0090:             volatility=volatility,
0091:             risk_free_rate=risk_free_rate,
0092:             option_type=option_type.lower()
0093:         )

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\components\portfolio_table.py
// ----------------------------------------
0001: # src/ui/components/portfolio_table.py
0002: 
0003: import streamlit as st
0004: import pandas as pd
0005: from typing import List
0006: from src.analytics.risk import Position # Relative import (still works within the same package)
0007: 
0008: class PortfolioTable:
0009:     """Interactive portfolio position display and management component."""
0010:     
0011:     def __init__(self, positions: List[Position]):
0012:         self.positions = positions
0013: 
0014:     def render(self):
0015:         """Render the portfolio positions table."""
0016:         if not self.positions:
0017:             st.info("No positions in portfolio. Add positions using the form above.")
0018:             return
0019: 
0020:         # Convert positions to DataFrame for display
0021:         data = []
0022:         for pos in self.positions:
0023:             data.append({
0024:                 'Type': pos.option_type.upper(),
0025:                 'Strike': f"${pos.strike:.2f}",
0026:                 'Expiry': f"{pos.expiry:.2f}y",
0027:                 'Quantity': pos.quantity,
0028:                 'Underlying': f"${pos.underlying_price:.2f}",
0029:                 'IV': f"{pos.volatility:.1%}",
0030:                 'Rate': f"{pos.risk_free_rate:.1%}"
0031:             })
0032:         
0033:         df = pd.DataFrame(data)
0034:         
0035:         # Display the table with conditional formatting
0036:         st.dataframe(
0037:             df.style.apply(self._style_negative_quantities, axis=1),
0038:             use_container_width=True
0039:         )
0040: 
0041:     @staticmethod
0042:     def _style_negative_quantities(row):
0043:         """Apply red color to negative quantities (short positions)."""
0044:         color = 'red' if row['Quantity'] < 0 else 'black'
0045:         return [f'color: {color}'] * len(row)

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\components\strategy_builder.py
// ----------------------------------------
0001: # src/ui/components/strategy_builder.py
0002: import streamlit as st
0003: from dataclasses import dataclass
0004: from typing import List, Optional
0005: from .option_inputs import OptionParameters
0006: 
0007: @dataclass
0008: class StrategyLeg:
0009:     """Represents a single leg in an options strategy."""
0010:     option_params: OptionParameters
0011:     quantity: int
0012:     position: str  # "long" or "short"
0013: 
0014: class StrategyBuilder:
0015:     """Component for building multi-leg option strategies."""
0016:     
0017:     def __init__(self):
0018:         if 'strategy_legs' not in st.session_state:
0019:             st.session_state.strategy_legs = []
0020: 
0021:     def render(self) -> List[StrategyLeg]:
0022:         """Render the strategy builder interface."""
0023:         st.subheader("Strategy Builder")
0024:         
0025:         # Add new leg form
0026:         with st.expander("Add Strategy Leg", expanded=True):
0027:             col1, col2 = st.columns(2)
0028:             
0029:             with col1:
0030:                 position = st.radio(
0031:                     "Position",
0032:                     ["Long", "Short"],
0033:                     horizontal=True,
0034:                     key="new_leg_position"
0035:                 )
0036:                 
0037:                 quantity = st.number_input(
0038:                     "Quantity",
0039:                     min_value=1,
0040:                     value=1,
0041:                     step=1,
0042:                     key="new_leg_quantity"
0043:                 )
0044:             
0045:             with col2:
0046:                 # Use OptionInputs component for leg parameters
0047:                 leg_inputs = OptionInputs(key_prefix=f"leg_{len(st.session_state.strategy_legs)}")
0048:                 option_params = leg_inputs.render()
0049:             
0050:             if st.button("Add Leg"):
0051:                 st.session_state.strategy_legs.append(
0052:                     StrategyLeg(
0053:                         option_params=option_params,
0054:                         quantity=quantity * (1 if position == "Long" else -1),
0055:                         position=position.lower()
0056:                     )
0057:                 )
0058:                 st.experimental_rerun()
0059:         
0060:         # Display current strategy composition
0061:         if st.session_state.strategy_legs:
0062:             st.subheader("Current Strategy Composition")
0063:             for i, leg in enumerate(st.session_state.strategy_legs):
0064:                 with st.container():
0065:                     col1, col2, col3 = st.columns([2, 2, 1])
0066:                     with col1:
0067:                         st.write(f"{leg.position.title()} {abs(leg.quantity)} "
0068:                                f"{leg.option_params.option_type.title()}")
0069:                     with col2:
0070:                         st.write(f"Strike: ${leg.option_params.strike_price:.2f}")
0071:                     with col3:
0072:                         if st.button("Remove", key=f"remove_{i}"):
0073:                             st.session_state.strategy_legs.pop(i)
0074:                             st.experimental_rerun()
0075:         
0076:         return st.session_state.strategy_legs

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\education.py
// ----------------------------------------
0001: # src/ui/education.py
0002: from dataclasses import dataclass
0003: from typing import Dict, List, Optional
0004: import numpy as np
0005: import plotly.graph_objects as go
0006: from plotly.subplots import make_subplots
0007: 
0008: @dataclass
0009: class ConceptExplanation:
0010:     """Container for educational content about an options concept."""
0011:     title: str
0012:     summary: str
0013:     detailed_explanation: str
0014:     formula: Optional[str] = None
0015:     examples: List[Dict[str, any]] = None
0016:     related_concepts: List[str] = None
0017:     interactive_elements: Dict[str, any] = None
0018: 
0019: class OptionsEducation:
0020:     """
0021:     Educational component providing interactive learning about options concepts.
0022:     
0023:     This class creates visualizations and explanations to help users understand:
0024:     1. Basic option concepts
0025:     2. Greeks and their interpretations
0026:     3. Volatility effects
0027:     4. Various pricing models
0028:     """
0029:     
0030:     def explain_black_scholes_assumptions(self) -> ConceptExplanation:
0031:         """Provide detailed explanation of Black-Scholes model assumptions."""
0032:         return ConceptExplanation(
0033:             title="Black-Scholes Model Assumptions",
0034:             summary="The Black-Scholes model relies on several key assumptions that simplify option pricing but may not fully reflect market reality.",
0035:             detailed_explanation="""
0036:             The Black-Scholes model makes the following assumptions:
0037:             
0038:             1. Geometric Brownian Motion (GBM):
0039:                - Stock prices follow a continuous random walk
0040:                - Returns are normally distributed
0041:                - Price changes are independent
0042:             
0043:             2. Constant Volatility:
0044:                - Volatility remains fixed throughout the option's life
0045:                - In reality, volatility tends to change and exhibit clustering
0046:             
0047:             3. No Dividends:
0048:                - The underlying stock pays no dividends
0049:                - Can be adjusted for known dividend payments
0050:             
0051:             4. European Exercise:
0052:                - Options can only be exercised at expiration
0053:                - American options require different models
0054:             
0055:             5. No Transaction Costs:
0056:                - Trading is frictionless with no fees or spreads
0057:                - Real markets have various costs
0058:             
0059:             6. Risk-Free Rate:
0060:                - Constant and known risk-free rate
0061:                - Can borrow and lend at this rate
0062:             
0063:             Understanding these assumptions is crucial for:
0064:             - Knowing when the model is appropriate
0065:             - Recognizing potential pricing errors
0066:             - Making necessary adjustments
0067:             """,
0068:             examples=[
0069:                 {
0070:                     "assumption": "Constant Volatility",
0071:                     "reality": "Volatility smile in market prices",
0072:                     "adjustment": "Use implied volatility surface"
0073:                 }
0074:             ],
0075:             related_concepts=[
0076:                 "Implied Volatility",
0077:                 "Option Greeks",
0078:                 "Risk-Neutral Pricing"
0079:             ]
0080:         )
0081:     
0082:     def visualize_option_payoff(self, option_type: str, K: float, premium: float,
0083:                               spot_range: Optional[np.ndarray] = None) -> go.Figure:
0084:         """
0085:         Create an interactive visualization of option payoff diagrams.
0086:         
0087:         This visualization shows:
0088:         1. Payoff at expiration
0089:         2. Current profit/loss
0090:         3. Break-even points
0091:         """
0092:         if spot_range is None:
0093:             spot_range = np.linspace(K * 0.5, K * 1.5, 100)
0094:         
0095:         # Calculate payoffs
0096:         if option_type.lower() == "call":
0097:             payoff = np.maximum(spot_range - K, 0)
0098:         else:
0099:             payoff = np.maximum(K - spot_range, 0)
0100:         
0101:         profit = payoff - premium
0102:         
0103:         # Create the plot
0104:         fig = go.Figure()
0105:         
0106:         # Add payoff line
0107:         fig.add_trace(go.Scatter(
0108:             x=spot_range,
0109:             y=payoff,
0110:             name="Payoff at Expiration",
0111:             line=dict(color="blue")
0112:         ))
0113:         
0114:         # Add profit line
0115:         fig.add_trace(go.Scatter(
0116:             x=spot_range,
0117:             y=profit,
0118:             name="Profit/Loss",
0119:             line=dict(color="green", dash="dash")
0120:         ))
0121:         
0122:         # Add break-even line
0123:         fig.add_hline(y=0, line=dict(color="gray", dash="dot"))
0124:         
0125:         # Update layout
0126:         fig.update_layout(
0127:             title=f"{option_type.capitalize()} Option Payoff Diagram",
0128:             xaxis_title="Underlying Price",
0129:             yaxis_title="Payoff/Profit",
0130:             showlegend=True,
0131:             hovermode="x unified"
0132:         )
0133:         
0134:         return fig
0135:     
0136:     def explain_greeks_interactively(self) -> Dict[str, go.Figure]:
0137:         """
0138:         Create interactive visualizations for understanding option Greeks.
0139:         
0140:         Returns a dictionary of Plotly figures demonstrating:
0141:         1. Delta and gamma relationships
0142:         2. Theta decay patterns
0143:         3. Vega sensitivity to volatility
0144:         4. Rho interest rate effects
0145:         """
0146:         figures = {}
0147:         
0148:         # Delta-Gamma visualization
0149:         fig_delta_gamma = make_subplots(
0150:             rows=2, cols=1,
0151:             subplot_titles=["Delta vs. Spot Price", "Gamma vs. Spot Price"]
0152:         )
0153:         
0154:         # Example parameters
0155:         S_range = np.linspace(80, 120, 100)
0156:         K = 100
0157:         r = 0.05
0158:         sigma = 0.2
0159:         T = 1.0
0160:         
0161:         # Calculate Greeks across spot range
0162:         deltas_call = []
0163:         deltas_put = []
0164:         gammas = []
0165:         
0166:         for S in S_range:
0167:             call_greeks = BlackScholesModel().calculate_greeks(
0168:                 S, K, r, sigma, T, "call"
0169:             )
0170:             put_greeks = BlackScholesModel().calculate_greeks(
0171:                 S, K, r, sigma, T, "put"
0172:             )
0173:             
0174:             deltas_call.append(call_greeks["delta"])
0175:             deltas_put.append(put_greeks["delta"])
0176:             gammas.append(call_greeks["gamma"])  # Same for calls and puts
0177:         
0178:         # Add traces
0179:         fig_delta_gamma.add_trace(
0180:             go.Scatter(x=S_range, y=deltas_call, name="Call Delta"),
0181:             row=1, col=1
0182:         )
0183:         fig_delta_gamma.add_trace(
0184:             go.Scatter(x=S_range, y=deltas_put, name="Put Delta"),
0185:             row=1, col=1
0186:         )
0187:         fig_delta_gamma.add_trace(
0188:             go.Scatter(x=S_range, y=gammas, name="Gamma"),
0189:             row=2, col=1
0190:         )
0191:         
0192:         figures["delta_gamma"] = fig_delta_gamma
0193:         
0194:         # Similar implementations for other Greeks...
0195:         # (Implementation abbreviated for brevity)
0196:         
0197:         return figures
0198:     
0199:     def create_interactive_tutorial(self) -> List[ConceptExplanation]:
0200:         """
0201:         Create a structured tutorial covering key options concepts.
0202:         
0203:         Returns a list of ConceptExplanation objects organized in learning order,
0204:         from basic to advanced topics.
0205:         """
0206:         tutorial = []
0207:         
0208:         # Basic Concepts
0209:         tutorial.append(ConceptExplanation(
0210:             title="Introduction to Options",
0211:             summary="Learn the fundamental concepts of options trading",
0212:             detailed_explanation="""
0213:             Options are financial contracts that give the holder the right,
0214:             but not the obligation, to buy (call) or sell (put) an underlying
0215:             asset at a specified price (strike) before or at expiration.
0216:             
0217:             Key Components:
0218:             1. Premium: The price paid for the option
0219:             2. Strike Price: The agreed-upon trading price
0220:             3. Expiration: When the option contract ends
0221:             4. Underlying: The asset the option is based on
0222:             
0223:             Options are useful for:
0224:             - Hedging against market movements
0225:             - Generating income 
0226:             
0227: 
0228:             - Generating income through premium collection
0229:             - Speculating on market movements with leverage
0230:             - Creating sophisticated trading strategies
0231:             
0232:             Understanding these fundamentals is essential before moving
0233:             to more advanced concepts like Greeks and pricing models.
0234:             """,
0235:             examples=[
0236:                 {
0237:                     "scenario": "Bullish on Stock",
0238:                     "action": "Buy Call Option",
0239:                     "explanation": "If you believe a stock trading at $100 will rise, you might buy a call option with a strike price of $105. Your maximum loss is limited to the premium paid, while your potential profit is unlimited if the stock rises above $105 plus the premium."
0240:                 },
0241:                 {
0242:                     "scenario": "Hedging Portfolio",
0243:                     "action": "Buy Put Option",
0244:                     "explanation": "If you own shares worth $10,000 and want to protect against a market decline, you could buy put options that give you the right to sell at a specified price, effectively creating a price floor for your portfolio."
0245:                 }
0246:             ],
0247:             related_concepts=["Moneyness", "Time Value", "Intrinsic Value"]
0248:         ))
0249:         
0250:         # Option Pricing Fundamentals
0251:         tutorial.append(ConceptExplanation(
0252:             title="Understanding Option Pricing",
0253:             summary="Learn what factors influence option prices and how they interact",
0254:             detailed_explanation="""
0255:             Option pricing is determined by several key factors that work together
0256:             in complex ways. Understanding these factors helps make better trading
0257:             decisions and manage risk effectively.
0258:             
0259:             Primary Pricing Factors:
0260:             
0261:             1. Underlying Price and Strike Price Relationship:
0262:                The relationship between these prices determines the option's intrinsic
0263:                value. An option has intrinsic value when it would be profitable to
0264:                exercise immediately. For calls, this means the stock price is above
0265:                the strike price; for puts, it's the reverse.
0266:             
0267:             2. Time to Expiration:
0268:                Options lose value as they approach expiration, a concept known as
0269:                time decay or theta. This decay is not linear - it accelerates as
0270:                expiration approaches, particularly for at-the-money options.
0271:             
0272:             3. Volatility:
0273:                Higher volatility increases option prices because it represents greater
0274:                uncertainty in future stock price movements. This relationship is
0275:                measured by vega, and it's why options are often described as
0276:                "volatility trades."
0277:             
0278:             4. Interest Rates:
0279:                While usually less significant than other factors, interest rates
0280:                affect option prices through the cost of carrying the underlying
0281:                position and the present value of the strike price.
0282:             
0283:             Understanding Price Behavior:
0284:             
0285:             Options exhibit complex price behavior because all these factors
0286:             interact simultaneously. For example, an increase in volatility
0287:             might overcome time decay, causing an option's price to rise even
0288:             as it approaches expiration.
0289:             """,
0290:             formula="""
0291:             Key Price Relationships:
0292:             Call Premium = Max(Stock Price - Strike Price, 0) + Time Value
0293:             Put Premium = Max(Strike Price - Stock Price, 0) + Time Value
0294:             """,
0295:             examples=[
0296:                 {
0297:                     "concept": "Time Decay",
0298:                     "scenario": "At-the-money call option with 30 days to expiration",
0299:                     "explanation": "The option might lose value more rapidly in the final two weeks before expiration than it did in the previous two weeks, demonstrating accelerating time decay."
0300:                 },
0301:                 {
0302:                     "concept": "Volatility Impact",
0303:                     "scenario": "Earnings announcement approaching",
0304:                     "explanation": "Option prices often increase as earnings approach due to higher implied volatility, even though time is passing and would normally reduce the option's value."
0305:                 }
0306:             ]
0307:         ))
0308:         
0309:         # Greeks and Risk Measures
0310:         tutorial.append(ConceptExplanation(
0311:             title="Option Greeks: Understanding Risk Measures",
0312:             summary="Master the fundamental risk measures used in options trading",
0313:             detailed_explanation="""
0314:             Option Greeks are essential risk measures that help traders understand
0315:             and manage their positions. Each Greek measures sensitivity to a
0316:             different market factor.
0317:             
0318:             Delta: The First Line of Defense
0319:             
0320:             Delta measures how much an option's price changes when the underlying
0321:             stock price changes by $1. It's often thought of as the equivalent
0322:             stock position - a delta of 0.5 means the option behaves like owning
0323:             50 shares of stock.
0324:             
0325:             More importantly, delta helps us understand probability. A call option
0326:             with a 0.30 delta suggests approximately a 30% chance of finishing
0327:             in-the-money at expiration. This probabilistic interpretation makes
0328:             delta invaluable for risk management.
0329:             
0330:             Gamma: The Rate of Change
0331:             
0332:             While delta tells us our current directional risk, gamma tells us
0333:             how quickly that risk is changing. High gamma positions can be
0334:             dangerous because their risk profile can change rapidly with small
0335:             moves in the underlying.
0336:             
0337:             Think of delta as your car's speed and gamma as its acceleration.
0338:             Just as it's important to know both how fast you're going and how
0339:             quickly you're speeding up or slowing down, understanding both
0340:             delta and gamma is crucial for risk management.
0341:             
0342:             Theta: The Cost of Time
0343:             
0344:             Theta represents the daily cost of holding an option position. It's
0345:             often called the "silent killer" because it steadily erodes option
0346:             value regardless of market movements. Understanding theta helps
0347:             traders decide whether to hold positions or take profits.
0348:             
0349:             Vega: Volatility Risk
0350:             
0351:             Vega measures sensitivity to volatility changes. It's particularly
0352:             important around earnings announcements, economic events, or market
0353:             stress when volatility can change dramatically. Long options have
0354:             positive vega (benefit from volatility increases) while short
0355:             options have negative vega.
0356:             """,
0357:             examples=[
0358:                 {
0359:                     "greek": "Delta",
0360:                     "position": "Long 1 Call with 0.60 delta",
0361:                     "interpretation": "A $1 increase in the stock price would increase the option value by $0.60. The position behaves like owning 60 shares of stock."
0362:                 },
0363:                 {
0364:                     "greek": "Gamma",
0365:                     "position": "At-the-money option near expiration",
0366:                     "interpretation": "High gamma means the position's delta can change dramatically with small price movements, requiring more active management."
0367:                 }
0368:             ],
0369:             related_concepts=[
0370:                 "Delta-Gamma Hedging",
0371:                 "Volatility Trading",
0372:                 "Risk Management Strategies"
0373:             ]
0374:         ))
0375:         
0376:         # Advanced Trading Strategies
0377:         tutorial.append(ConceptExplanation(
0378:             title="Option Strategies and Portfolio Management",
0379:             summary="Learn how to combine options into sophisticated trading strategies",
0380:             detailed_explanation="""
0381:             Options can be combined in various ways to create positions with
0382:             specific risk-reward characteristics. Understanding these strategies
0383:             helps traders choose the right approach for their market outlook
0384:             and risk tolerance.
0385:             
0386:             Vertical Spreads: Defined Risk Directional Trading
0387:             
0388:             Vertical spreads involve buying and selling options of the same type
0389:             and expiration but different strikes. They offer defined risk and
0390:             reward, making them popular for directional trading. The tradeoff
0391:             is capped profit potential in exchange for reduced cost and risk.
0392:             
0393:             Calendar Spreads: Exploiting Time Decay
0394:             
0395:             Calendar spreads involve options with the same strike but different
0396:             expirations. They profit from time decay differences between near
0397:             and far-term options. These positions require careful management
0398:             of both time and volatility risk.
0399:             
0400:             Portfolio Protection Strategies
0401:             
0402:             Options are powerful tools for portfolio protection. Common approaches
0403:             include:
0404:             
0405:             1. Protective Puts: Buying puts to create a floor for stock positions
0406:             2. Collars: Combining protective puts with covered calls to reduce cost
0407:             3. VIX Hedging: Using volatility products to hedge market stress
0408:             
0409:             Each approach has its own cost-benefit tradeoff, and the choice
0410:             depends on factors like market environment, cost tolerance, and
0411:             protection needs.
0412:             """,
0413:             examples=[
0414:                 {
0415:                     "strategy": "Bull Call Spread",
0416:                     "construction": "Buy lower strike call, sell higher strike call",
0417:                     "use_case": "Bullish outlook with defined risk and lower cost than outright call purchase"
0418:                 },
0419:                 {
0420:                     "strategy": "Iron Condor",
0421:                     "construction": "Sell OTM put spread and call spread",
0422:                     "use_case": "Profit from range-bound market while limiting risk"
0423:                 }
0424:             ]
0425:         ))
0426:         
0427:         return tutorial
0428: 
0429:     def create_strategy_visualization(self, strategy_name: str,
0430:                                    spot_range: Optional[np.ndarray] = None) -> go.Figure:
0431:         """
0432:         Create interactive visualizations of common option strategies.
0433:         
0434:         This method generates payoff and profit diagrams for complex option
0435:         strategies, helping users understand their risk-reward characteristics.
0436:         Each visualization includes:
0437:         - Payoff at expiration
0438:         - Current profit/loss
0439:         - Break-even points
0440:         - Component position contributions
0441:         - Risk measures at different price points
0442:         """
0443:         if spot_range is None:
0444:             spot_range = np.linspace(80, 120, 200)
0445:         
0446:         fig = go.Figure()
0447:         
0448:         if strategy_name.lower() == "bull_call_spread":
0449:             # Example parameters for a bull call spread
0450:             lower_strike = 100
0451:             upper_strike = 105
0452:             lower_premium = 3
0453:             upper_premium = 1
0454:             
0455:             # Calculate individual position payoffs
0456:             long_call = np.maximum(spot_range - lower_strike, 0) - lower_premium
0457:             short_call = -(np.maximum(spot_range - upper_strike, 0) - upper_premium)
0458:             total = long_call + short_call
0459:             
0460:             # Add traces for each component
0461:             fig.add_trace(go.Scatter(
0462:                 x=spot_range,
0463:                 y=long_call,
0464:                 name="Long Lower Strike Call",
0465:                 line=dict(dash="dot", color="blue")
0466:             ))
0467:             
0468:             fig.add_trace(go.Scatter(
0469:                 x=spot_range,
0470:                 y=short_call,
0471:                 name="Short Upper Strike Call",
0472:                 line=dict(dash="dot", color="red")
0473:             ))
0474:             
0475:             fig.add_trace(go.Scatter(
0476:                 x=spot_range,
0477:                 y=total,
0478:                 name="Total Strategy",
0479:                 line=dict(color="green", width=2)
0480:             ))
0481:             
0482:             # Add break-even line and annotation
0483:             break_even = lower_strike + (lower_premium - upper_premium)
0484:             fig.add_hline(y=0, line=dict(color="gray", dash="dash"))
0485:             fig.add_vline(x=break_even, line=dict(color="gray", dash="dash"))
0486:             
0487:             fig.add_annotation(
0488:                 x=break_even,
0489:                 y=0,
0490:                 text=f"Break-even: {break_even:.2f}",
0491:                 showarrow=True,
0492:                 arrowhead=1
0493:             )
0494:             
0495:             # Update layout
0496:             fig.update_layout(
0497:                 title="Bull Call Spread Payoff Diagram",
0498:                 xaxis_title="Underlying Price",
0499:                 yaxis_title="Profit/Loss",
0500:                 showlegend=True,
0501:                 hovermode="x unified",
0502:                 annotations=[
0503:                     dict(
0504:                         text=f"Max Profit: {upper_strike - lower_strike - (lower_premium - upper_premium):.2f}",
0505:                         xref="paper", yref="paper",
0506:                         x=1.02, y=0.95,
0507:                         showarrow=False
0508:                     ),
0509:                     dict(
0510:                         text=f"Max Loss: {lower_premium - upper_premium:.2f}",
0511:                         xref="paper", yref="paper",
0512:                         x=1.02, y=0.85,
0513:                         showarrow=False
0514:                     )
0515:                 ]
0516:             )
0517:         
0518:         elif strategy_name.lower() == "iron_condor":
0519:             # Similar implementation for iron condor
0520:             # (Implementation abbreviated for brevity)
0521:             pass
0522:         
0523:         return fig
0524:     
0525:     def visualize_vol_surface(self) -> go.Figure:
0526:         """
0527:         Create an interactive 3D visualization of the volatility surface.
0528:         
0529:         This visualization helps users understand:
0530:         - Volatility smile across strikes
0531:         - Term structure of volatility
0532:         - Put-call volatility parity
0533:         """
0534:         # Generate sample data
0535:         strikes = np.linspace(80, 120, 20)
0536:         maturities = np.linspace(0.1, 2, 20)
0537:         K, T = np.meshgrid(strikes, maturities)
0538:         
0539:         # Create a sample volatility surface
0540:         # In practice, this would use market data
0541:         moneyness = K / 100  # Assuming current price is 100
0542:         vol_surface = 0.2 + 0.1 * (moneyness - 1)**2 + 0.05 * np.exp(-T)
0543:         
0544:         # Create the 3D surface plot
0545:         fig = go.Figure(data=[go.Surface(
0546:             x=K,
0547:             y=T,
0548:             z=vol_surface,
0549:             colorscale='Viridis'
0550:         )])
0551:         
0552:         # Update layout
0553:         fig.update_layout(
0554:             title='Implied Volatility Surface',
0555:             scene=dict(
0556:                 xaxis_title='Strike',
0557:                 yaxis_title='Time to Maturity',
0558:                 zaxis_title='Implied Volatility',
0559:                 camera=dict(
0560:                     eye=dict(x=1.5, y=1.5, z=1.2)
0561:                 )
0562:             ),
0563:             width=800,
0564:             height=800
0565:         )
0566:         
0567:         return fig
0568:     
0569:     def create_interactive_simulation(self, n_paths: int = 1000,
0570:                                     time_steps: int = 252) -> go.Figure:
0571:         """
0572:         Create an interactive Monte Carlo simulation visualization.
0573:         
0574:         This helps users understand:
0575:         - Path dependency of options
0576:         - Probability distributions of outcomes
0577:         - The relationship between volatility and price paths
0578:         """
0579:         # Generate price paths
0580:         S0 = 100  # Initial price
0581:         mu = 0.05  # Drift
0582:         sigma = 0.2  # Volatility
0583:         T = 1.0  # Time horizon
0584:         dt = T / time_steps
0585:         
0586:         # Generate random walks
0587:         Z = np.random.standard_normal((n_paths, time_steps))
0588:         paths = np.zeros((n_paths, time_steps + 1))
0589:         paths[:, 0] = S0
0590:         
0591:         for t in range(1, time_steps + 1):
0592:             paths[:, t] = paths[:, t-1] * np.exp(
0593:                 (mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z[:, t-1]
0594:             )
0595:         
0596:         # Create visualization
0597:         fig = go.Figure()
0598:         
0599:         # Add some sample paths
0600:         time_points = np.linspace(0, T, time_steps + 1)
0601:         for i in range(min(10, n_paths)):  # Show first 10 paths
0602:             fig.add_trace(go.Scatter(
0603:                 x=time_points,
0604:                 y=paths[i, :],
0605:                 mode='lines',
0606:                 line=dict(width=1),
0607:                 showlegend=False,
0608:                 opacity=0.6
0609:             ))
0610:         
0611:         # Add mean path
0612:         mean_path = np.mean(paths, axis=0)
0613:         fig.add_trace(go.Scatter(
0614:             x=time_points,
0615:             y=mean_path,
0616:             mode='lines',
0617:             name='Mean Path',
0618:             line=dict(color='red', width=2)
0619:         ))
0620: 
0621:         # Add confidence intervals
0622:         upper_95 = np.percentile(paths, 97.5, axis=0)
0623:         lower_95 = np.percentile(paths, 2.5, axis=0)
0624:         
0625:         fig.add_trace(go.Scatter(
0626:             x=time_points,
0627:             y=upper_95,
0628:             mode='lines',
0629:             name='95% Confidence Interval',
0630:             line=dict(color='gray', dash='dash'),
0631:             showlegend=True
0632:         ))
0633:         
0634:         fig.add_trace(go.Scatter(
0635:             x=time_points,
0636:             y=lower_95,
0637:             mode='lines',
0638:             line=dict(color='gray', dash='dash'),
0639:             fill='tonexty',  # Fill area between traces
0640:             showlegend=False
0641:         ))
0642:         
0643:         # Add expected value line (theoretical)
0644:         expected_value = S0 * np.exp(mu * time_points)
0645:         fig.add_trace(go.Scatter(
0646:             x=time_points,
0647:             y=expected_value,
0648:             mode='lines',
0649:             name='Expected Value (Theory)',
0650:             line=dict(color='green', dash='dot', width=2)
0651:         ))
0652:         
0653:         # Update layout with educational annotations
0654:         fig.update_layout(
0655:             title='Monte Carlo Price Path Simulation',
0656:             xaxis_title='Time (years)',
0657:             yaxis_title='Stock Price',
0658:             showlegend=True,
0659:             hovermode='x unified',
0660:             annotations=[
0661:                 dict(
0662:                     text='The shaded area shows the 95% confidence interval<br>'
0663:                          'for future stock prices based on the volatility input.',
0664:                     xref='paper', yref='paper',
0665:                     x=1.02, y=0.95,
0666:                     showarrow=False,
0667:                     align='left'
0668:                 ),
0669:                 dict(
0670:                     text=f'Parameters:<br>'
0671:                          f'Initial Price: ${S0}<br>'
0672:                          f'Drift: {mu:.1%}<br>'
0673:                          f'Volatility: {sigma:.1%}',
0674:                     xref='paper', yref='paper',
0675:                     x=1.02, y=0.85,
0676:                     showarrow=False,
0677:                     align='left'
0678:                 )
0679:             ]
0680:         )
0681:         
0682:         # Add shapes to highlight important features
0683:         fig.add_shape(
0684:             type="rect",
0685:             x0=0.8, x1=1.0,  # Highlight end of simulation
0686:             y0=min(lower_95[-1], paths.min()),
0687:             y1=max(upper_95[-1], paths.max()),
0688:             fillcolor="rgba(255,0,0,0.1)",
0689:             line=dict(width=0),
0690:             layer="below"
0691:         )
0692:         
0693:         return fig
0694:     
0695:     def create_interactive_greek_explorer(self) -> go.Figure:
0696:         """
0697:         Create an interactive visualization to explore how Greeks change
0698:         with different parameters.
0699:         
0700:         This visualization helps users understand:
0701:         - How Greeks evolve over time
0702:         - The relationship between Greeks and market parameters
0703:         - Risk management implications of Greek exposures
0704:         """
0705:         # Create a subplot figure with multiple Greeks
0706:         fig = make_subplots(
0707:             rows=2, cols=2,
0708:             subplot_titles=('Delta', 'Gamma', 'Theta', 'Vega'),
0709:             vertical_spacing=0.15,
0710:             horizontal_spacing=0.1
0711:         )
0712:         
0713:         # Generate sample data
0714:         S = 100  # Current stock price
0715:         K = 100  # Strike price
0716:         r = 0.05  # Risk-free rate
0717:         sigma = 0.2  # Volatility
0718:         T = 1.0  # Time to maturity
0719:         
0720:         # Create price range for x-axis
0721:         spot_range = np.linspace(70, 130, 100)
0722:         
0723:         # Calculate Greeks at different spot prices
0724:         deltas_call = []
0725:         deltas_put = []
0726:         gammas = []
0727:         thetas = []
0728:         vegas = []
0729:         
0730:         for spot in spot_range:
0731:             # Calculate call Greeks
0732:             call_greeks = BlackScholesModel().calculate_greeks(
0733:                 spot, K, r, sigma, T, "call"
0734:             )
0735:             # Calculate put Greeks
0736:             put_greeks = BlackScholesModel().calculate_greeks(
0737:                 spot, K, r, sigma, T, "put"
0738:             )
0739:             
0740:             deltas_call.append(call_greeks["delta"])
0741:             deltas_put.append(put_greeks["delta"])
0742:             gammas.append(call_greeks["gamma"])  # Same for calls and puts
0743:             thetas.append(call_greeks["theta"])
0744:             vegas.append(call_greeks["vega"])
0745:         
0746:         # Add traces for each Greek
0747:         # Delta subplot
0748:         fig.add_trace(
0749:             go.Scatter(x=spot_range, y=deltas_call, name="Call Delta",
0750:                       line=dict(color='blue')),
0751:             row=1, col=1
0752:         )
0753:         fig.add_trace(
0754:             go.Scatter(x=spot_range, y=deltas_put, name="Put Delta",
0755:                       line=dict(color='red')),
0756:             row=1, col=1
0757:         )
0758:         
0759:         # Gamma subplot
0760:         fig.add_trace(
0761:             go.Scatter(x=spot_range, y=gammas, name="Gamma",
0762:                       line=dict(color='green')),
0763:             row=1, col=2
0764:         )
0765:         
0766:         # Theta subplot
0767:         fig.add_trace(
0768:             go.Scatter(x=spot_range, y=thetas, name="Theta",
0769:                       line=dict(color='purple')),
0770:             row=2, col=1
0771:         )
0772:         
0773:         # Vega subplot
0774:         fig.add_trace(
0775:             go.Scatter(x=spot_range, y=vegas, name="Vega",
0776:                       line=dict(color='orange')),
0777:             row=2, col=2
0778:         )
0779:         
0780:         # Update layout with educational annotations
0781:         fig.update_layout(
0782:             height=800,
0783:             showlegend=True,
0784:             title_text="Interactive Greek Explorer",
0785:             annotations=[
0786:                 dict(
0787:                     text="Parameters:<br>"
0788:                          f"Strike: ${K}<br>"
0789:                          f"Volatility: {sigma:.1%}<br>"
0790:                          f"Time: {T:.1f} years",
0791:                     xref="paper", yref="paper",
0792:                     x=1.02, y=1.0,
0793:                     showarrow=False,
0794:                     align='left'
0795:                 )
0796:             ]
0797:         )
0798:         
0799:         # Update axes labels
0800:         fig.update_xaxes(title_text="Stock Price", row=2, col=1)
0801:         fig.update_xaxes(title_text="Stock Price", row=2, col=2)
0802:         fig.update_yaxes(title_text="Value", row=1, col=1)
0803:         fig.update_yaxes(title_text="Value", row=2, col=1)
0804:         
0805:         return fig

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\option_visualizer.py
// ----------------------------------------
0001: # src/ui/option_visualizer.py
0002: import streamlit as st
0003: from typing import Dict, List, Optional
0004: import plotly.graph_objects as go
0005: 
0006: from src.models.black_scholes import BlackScholesModel # Absolute import
0007: from src.models.binomial import BinomialModel # Absolute import
0008: from src.models.monte_carlo import MonteCarloModel # Absolute import
0009: from src.analytics.portfolio_visualization import PortfolioVisualizer # Absolute import
0010: from src.analytics.strategy_visualization import StrategyVisualizer # Absolute import
0011: from src.analytics.risk import RiskAnalyzer # Absolute import
0012: from src.analytics.volatility import VolatilitySurface # Absolute import
0013: from .education import OptionsEducation # Relative import (still works within the same package)
0014: from src.config import AppConfig # Absolute import
0015: from .pages.home import render_page as render_home
0016: from .pages.option_pricing import render_page as render_option_pricing
0017: from .pages.portfolio import render_page as render_portfolio
0018: from .pages.education import render_page as render_education
0019: from .pages.strategy_builder import render_page as render_strategy_builder
0020: 
0021: 
0022: class OptionVisualizerApp:
0023:     """
0024:     Main application class for the Option Pricing Visualizer.
0025:     
0026:     This class orchestrates the entire application, providing:
0027:     1. Clean, intuitive UI layout
0028:     2. Interactive model parameter inputs
0029:     3. Real-time visualization updates
0030:     4. Educational content integration
0031:     5. Advanced analytics features
0032:     """
0033:     
0034:     def __init__(self):
0035:         """Initialize application components and state."""
0036:         # Initialize pricing models
0037:         self.black_scholes = BlackScholesModel()
0038:         self.binomial = BinomialModel()
0039:         self.monte_carlo = MonteCarloModel()
0040:         
0041:         # Initialize visualization components
0042:         self.portfolio_viz = PortfolioVisualizer()
0043:         self.strategy_viz = StrategyVisualizer(self.black_scholes)
0044:         self.vol_analyzer = RiskAnalyzer(self.black_scholes)
0045:         
0046:         # Initialize educational content
0047:         self.education = OptionsEducation()
0048:         
0049:         # Set page configuration
0050:         st.set_page_config(
0051:             page_title="Option Pricing Visualizer",
0052:             layout="wide",
0053:             initial_sidebar_state="expanded"
0054:         )
0055:         
0056:         # Apply custom styling
0057:         self._apply_custom_styling()
0058:     
0059:     def run(self):
0060:         """Main application entry point."""
0061:         # Display header and introduction
0062:         self._render_header()
0063:         
0064:         # Create main navigation
0065:         tab_options = [
0066:             "Option Pricing",
0067:             "Strategy Builder",
0068:             "Portfolio Analysis",
0069:             "Risk Analysis",
0070:             "Learning Center"
0071:         ]
0072:         
0073:         selected_tab = st.sidebar.radio("Navigation", tab_options)
0074:         
0075:         # Render selected tab content
0076:         if selected_tab == "Option Pricing":
0077:             self._render_pricing_tab()
0078:         elif selected_tab == "Strategy Builder":
0079:             self._render_strategy_tab()
0080:         elif selected_tab == "Portfolio Analysis":
0081:             self._render_portfolio_tab()
0082:         else:  # Learning Center
0083:             self._render_learning_tab()
0084:     
0085:     def _render_header(self):
0086:         """Render application header with title and introduction."""
0087:         st.markdown(
0088:             """
0089:             <h1 style='text-align: center;'>Option Pricing Visualizer</h1>
0090:             
0091:             <p style='text-align: center; font-size: 1.2em;'>
0092:             An interactive tool for understanding option pricing, strategies, and risk management
0093:             </p>
0094:             """,
0095:             unsafe_allow_html=True
0096:         )
0097:         
0098:         with st.expander("About this Tool", expanded=False):
0099:             st.markdown(
0100:                 """
0101:                 This tool helps you understand options through:
0102:                 - Interactive pricing model comparisons
0103:                 - Visual strategy analysis
0104:                 - Portfolio risk assessment
0105:                 - Educational content and tutorials
0106:                 
0107:                 Start by selecting a section from the sidebar navigation.
0108:                 """
0109:             )
0110:     
0111:     def _render_pricing_tab(self):
0112:         """Render the option pricing analysis tab."""
0113:         st.header("Option Pricing Analysis")
0114:         
0115:         # Create two columns for input parameters
0116:         col1, col2 = st.columns(2)
0117:         
0118:         with col1:
0119:             # Basic parameters
0120:             st.subheader("Option Parameters")
0121:             underlying_price = st.number_input(
0122:                 "Underlying Price",
0123:                 min_value=1.0,
0124:                 value=100.0,
0125:                 step=1.0,
0126:                 help="Current price of the underlying asset"
0127:             )
0128:             
0129:             strike_price = st.number_input(
0130:                 "Strike Price",
0131:                 min_value=1.0,
0132:                 value=100.0,
0133:                 step=1.0,
0134:                 help="Strike price of the option"
0135:             )
0136:             
0137:             time_to_expiry = st.slider(
0138:                 "Time to Expiry (Years)",
0139:                 min_value=0.1,
0140:                 max_value=2.0,
0141:                 value=1.0,
0142:                 step=0.1,
0143:                 help="Time until option expiration in years"
0144:             )
0145:         
0146:         with col2:
0147:             # Market parameters
0148:             st.subheader("Market Parameters")
0149:             volatility = st.slider(
0150:                 "Volatility",
0151:                 min_value=0.1,
0152:                 max_value=1.0,
0153:                 value=0.2,
0154:                 step=0.05,
0155:                 help="Annualized volatility"
0156:             )
0157:             
0158:             risk_free_rate = st.slider(
0159:                 "Risk-free Rate",
0160:                 min_value=0.0,
0161:                 max_value=0.1,
0162:                 value=0.05,
0163:                 step=0.01,
0164:                 help="Annual risk-free interest rate"
0165:             )
0166:         
0167:         # Model selection and comparison
0168:         st.subheader("Model Selection")
0169:         models = st.multiselect(
0170:             "Select Models to Compare",
0171:             ["Black-Scholes", "Binomial", "Monte Carlo"],
0172:             default=["Black-Scholes"]
0173:         )
0174:         
0175:         option_type = st.radio(
0176:             "Option Type",
0177:             ["Call", "Put"],
0178:             horizontal=True
0179:         )
0180:         
0181:         if not models:
0182:             st.warning("Please select at least one model to analyze.")
0183:             return
0184:         
0185:         # Calculate and display results
0186:         results = self._calculate_model_results(
0187:             models,
0188:             underlying_price,
0189:             strike_price,
0190:             time_to_expiry,
0191:             volatility,
0192:             risk_free_rate,
0193:             option_type.lower()
0194:         )
0195:         
0196:         self._display_pricing_results(results)
0197:         
0198:         # Display interactive visualizations
0199:         st.subheader("Visual Analysis")
0200:         visualization_type = st.selectbox(
0201:             "Select Visualization",
0202:             ["Price vs. Underlying", "Greeks Profile", "Time Decay"]
0203:         )
0204:         
0205:         self._display_pricing_visualization(
0206:             visualization_type,
0207:             results,
0208:             underlying_price,
0209:             strike_price
0210:         )
0211:     
0212:     def _calculate_model_results(self, models: List[str], S: float, K: float,
0213:                                T: float, sigma: float, r: float,
0214:                                option_type: str) -> Dict[str, float]:
0215:         """Calculate option prices and Greeks using selected models."""
0216:         results = {}
0217:         
0218:         for model in models:
0219:             if model == "Black-Scholes":
0220:                 if option_type == "call":
0221:                     result = self.black_scholes.price_call(S, K, r, sigma, T)
0222:                 else:
0223:                     result = self.black_scholes.price_put(S, K, r, sigma, T)
0224:             elif model == "Binomial":
0225:                 result = self.binomial.price_option(
0226:                     S, K, r, sigma, T,
0227:                     option_type=option_type,
0228:                     exercise="european"
0229:                 )
0230:             else:  # Monte Carlo
0231:                 if option_type == "call":
0232:                     result = self.monte_carlo.price_call(S, K, r, sigma, T)
0233:                 else:
0234:                     result = self.monte_carlo.price_put(S, K, r, sigma, T)
0235:             
0236:             results[model] = result
0237:         
0238:         return results
0239:     
0240:     def _display_pricing_results(self, results: Dict[str, float]):
0241:         """Display pricing results in a clear, organized manner."""
0242:         st.subheader("Pricing Results")
0243:         
0244:         # Create columns for each model
0245:         cols = st.columns(len(results))
0246:         
0247:         for col, (model, result) in zip(cols, results.items()):
0248:             with col:
0249:                 st.metric(
0250:                     label=f"{model} Price",
0251:                     value=f"${result.price:.2f}"
0252:                 )
0253:                 
0254:                 if result.greeks:
0255:                     st.markdown("#### Greeks")
0256:                     for greek, value in result.greeks.items():
0257:                         st.metric(greek.capitalize(), f"{value:.4f}")
0258:     
0259:     def _display_pricing_visualization(self, viz_type: str, results: Dict,
0260:                                     current_price: float, strike: float):
0261:         """Create and display interactive pricing visualizations."""
0262:         # Implementation of visualization logic...
0263:         pass
0264: 
0265:     def _render_strategy_tab(self):
0266:         """Render the strategy builder and analysis tab."""
0267:         st.header("Options Strategy Builder")
0268:         
0269:         # Strategy selection or custom builder
0270:         strategy_mode = st.radio(
0271:             "Strategy Mode",
0272:             ["Pre-defined Strategies", "Custom Strategy Builder"],
0273:             horizontal=True
0274:         )
0275:         
0276:         if strategy_mode == "Pre-defined Strategies":
0277:             strategy = st.selectbox(
0278:                 "Select Strategy",
0279:                 [
0280:                     "Bull Call Spread",
0281:                     "Bear Put Spread",
0282:                     "Iron Condor",
0283:                     "Butterfly Spread",
0284:                     "Calendar Spread",
0285:                     "Straddle",
0286:                     "Strangle"
0287:                 ]
0288:             )
0289:             
0290:             # Display strategy information
0291:             st.markdown(self.education.get_strategy_description(strategy))
0292:             
0293:             # Strategy parameters
0294:             col1, col2 = st.columns(2)
0295:             with col1:
0296:                 underlying_price = st.number_input(
0297:                     "Underlying Price",
0298:                     min_value=1.0,
0299:                     value=100.0,
0300:                     step=1.0
0301:                 )
0302:                 
0303:                 width = st.slider(
0304:                     "Strategy Width",
0305:                     min_value=5,
0306:                     max_value=50,
0307:                     value=10,
0308:                     step=5,
0309:                     help="Distance between strikes in the strategy"
0310:                 )
0311:             
0312:             with col2:
0313:                 expiry = st.slider(
0314:                     "Days to Expiration",
0315:                     min_value=7,
0316:                     max_value=365,
0317:                     value=30,
0318:                     step=7
0319:                 )
0320:                 
0321:                 size = st.number_input(
0322:                     "Position Size (contracts)",
0323:                     min_value=1,
0324:                     value=1,
0325:                     step=1
0326:                 )
0327:             
0328:             # Generate and display strategy analysis
0329:             strategy_profile = self._generate_strategy_profile(
0330:                 strategy,
0331:                 underlying_price,
0332:                 width,
0333:                 expiry,
0334:                 size
0335:             )
0336:             
0337:             self._display_strategy_analysis(strategy_profile)
0338:             
0339:         else:  # Custom Strategy Builder
0340:             st.subheader("Build Custom Strategy")
0341:             
0342:             # Initialize or get existing legs
0343:             if 'strategy_legs' not in st.session_state:
0344:                 st.session_state.strategy_legs = []
0345:             
0346:             # Add new leg form
0347:             with st.expander("Add Strategy Leg", expanded=True):
0348:                 col1, col2 = st.columns(2)
0349:                 
0350:                 with col1:
0351:                     option_type = st.selectbox(
0352:                         "Option Type",
0353:                         ["Call", "Put"],
0354:                         key="new_leg_type"
0355:                     )
0356:                     
0357:                     position = st.radio(
0358:                         "Position",
0359:                         ["Long", "Short"],
0360:                         horizontal=True,
0361:                         key="new_leg_position"
0362:                     )
0363:                 
0364:                 with col2:
0365:                     strike = st.number_input(
0366:                         "Strike Price",
0367:                         min_value=1.0,
0368:                         value=100.0,
0369:                         step=1.0,
0370:                         key="new_leg_strike"
0371:                     )
0372:                     
0373:                     quantity = st.number_input(
0374:                         "Quantity",
0375:                         min_value=1,
0376:                         value=1,
0377:                         step=1,
0378:                         key="new_leg_quantity"
0379:                     )
0380:                 
0381:                 if st.button("Add Leg"):
0382:                     st.session_state.strategy_legs.append({
0383:                         'type': option_type,
0384:                         'position': position,
0385:                         'strike': strike,
0386:                         'quantity': quantity * (1 if position == "Long" else -1)
0387:                     })
0388:             
0389:             # Display current strategy composition
0390:             if st.session_state.strategy_legs:
0391:                 st.subheader("Current Strategy Composition")
0392:                 for i, leg in enumerate(st.session_state.strategy_legs):
0393:                     col1, col2, col3 = st.columns([2, 2, 1])
0394:                     with col1:
0395:                         st.write(f"{leg['position']} {leg['quantity']} {leg['type']}")
0396:                     with col2:
0397:                         st.write(f"Strike: {leg['strike']}")
0398:                     with col3:
0399:                         if st.button("Remove", key=f"remove_{i}"):
0400:                             st.session_state.strategy_legs.pop(i)
0401:                             st.experimental_rerun()
0402:                 
0403:                 # Analyze custom strategy
0404:                 custom_profile = self._generate_custom_strategy_profile(
0405:                     st.session_state.strategy_legs
0406:                 )
0407:                 self._display_strategy_analysis(custom_profile)
0408:             
0409:             else:
0410:                 st.info("Add legs to your strategy using the form above.")
0411:     
0412:     def _render_portfolio_tab(self):
0413:         """Render the portfolio analysis tab."""
0414:         st.header("Portfolio Analysis")
0415:         
0416:         # Portfolio input method selection
0417:         input_method = st.radio(
0418:             "Input Method",
0419:             ["Manual Entry", "Upload Positions", "Sample Portfolio"],
0420:             horizontal=True
0421:         )
0422:         
0423:         if input_method == "Manual Entry":
0424:             # Similar to strategy builder but with more position details
0425:             self._render_manual_portfolio_entry()
0426:         
0427:         elif input_method == "Upload Positions":
0428:             uploaded_file = st.file_uploader(
0429:                 "Upload Portfolio CSV",
0430:                 type=['csv'],
0431:                 help="CSV file with columns: Type,Strike,Expiry,Quantity,Premium"
0432:             )
0433:             
0434:             if uploaded_file:
0435:                 positions = self._parse_portfolio_file(uploaded_file)
0436:                 self._analyze_portfolio(positions)
0437:         
0438:         else:  # Sample Portfolio
0439:             sample_name = st.selectbox(
0440:                 "Select Sample Portfolio",
0441:                 ["Covered Call Strategy", "Iron Condor Portfolio", "Delta-Neutral"]
0442:             )
0443:             
0444:             positions = self._get_sample_portfolio(sample_name)
0445:             self._analyze_portfolio(positions)

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\pages\__init__.py
// ----------------------------------------

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\pages\education.py
// ----------------------------------------
0001: # src/ui/pages/education.py
0002: 
0003: import streamlit as st
0004: from src.ui.components.charts import OptionPayoffChart
0005: from src.models.black_scholes import BlackScholesModel
0006: from src.analytics.risk import Position
0007: 
0008: def render_page():
0009:     """
0010:     Render the educational content page.
0011:     
0012:     This page provides interactive learning materials about:
0013:     1. Basic option concepts
0014:     2. Greeks and risk measures
0015:     3. Trading strategies
0016:     4. Portfolio management principles
0017:     """
0018:     st.header("Options Education Center")
0019:     
0020:     # Topic selection
0021:     topic = st.selectbox(
0022:         "Select Topic",
0023:         ["Option Basics", "Greeks Explained", "Trading Strategies", "Risk Management"]
0024:     )
0025:     
0026:     if topic == "Option Basics":
0027:         _render_option_basics()
0028:     elif topic == "Greeks Explained":
0029:         _render_greeks_explanation()
0030:     elif topic == "Trading Strategies":
0031:         _render_strategy_education()
0032:     else:
0033:         _render_risk_management()
0034: 
0035: def _render_option_basics():
0036:     """Render basic options education content."""
0037:     st.subheader("Understanding Options")
0038:     
0039:     st.markdown("""
0040:         Options are financial contracts that give the holder the right, but not the
0041:         obligation, to buy (call) or sell (put) an underlying asset at a specified
0042:         price (strike) before or at expiration.
0043:         
0044:         Let's explore how options work through interactive examples:
0045:     """)
0046:     
0047:     # Interactive option payoff demonstration
0048:     st.subheader("Option Payoff Demonstration")
0049:     
0050:     col1, col2 = st.columns(2)
0051:     with col1:
0052:         option_type = st.selectbox("Option Type", ["Call", "Put"])
0053:         strike = st.number_input("Strike Price", value=100.0)
0054:     with col2:
0055:         premium = st.number_input("Option Premium", value=5.0)
0056:         quantity = st.number_input("Number of Contracts", value=1)
0057:     
0058:     # Create demo position
0059:     position = Position(
0060:         option_type=option_type.lower(),
0061:         strike=strike,
0062:         expiry=1.0,
0063:         quantity=quantity,
0064:         underlying_price=100.0,
0065:         volatility=0.2,
0066:         risk_free_rate=0.05
0067:     )
0068:     
0069:     # Display payoff diagram
0070:     payoff_chart = OptionPayoffChart()
0071:     fig = payoff_chart.create_payoff_chart([position])
0072:     st.plotly_chart(fig)
0073:     
0074:     # Educational explanations
0075:     st.markdown(f"""
0076:         ### Key Points:
0077:         
0078:         - This {option_type.lower()} option gives you the right to 
0079:           {'buy' if option_type.lower() == 'call' else 'sell'} at ${strike:.2f}
0080:         - Maximum loss is limited to the premium paid: ${premium * quantity:.2f}
0081:         - Break-even price: ${strike + premium if option_type.lower() == 'call' else strike - premium:.2f}
0082:     """)
0083: 
0084: def _render_greeks_explanation():
0085:     """Render interactive Greeks education content."""
0086:     st.subheader("Understanding Option Greeks")
0087:     
0088:     # Create interactive Greek visualization
0089:     model = BlackScholesModel()
0090:     
0091:     st.markdown("""
0092:         Greeks measure how option prices change with respect to various factors.
0093:         Adjust the parameters below to see how Greeks behave:
0094:     """)
0095:     
0096:     # Interactive parameters
0097:     col1, col2 = st.columns(2)
0098:     with col1:
0099:         spot = st.slider("Underlying Price", 80.0, 120.0, 100.0)
0100:         strike = st.number_input("Strike Price", value=100.0)
0101:     with col2:
0102:         vol = st.slider("Volatility", 0.1, 0.5, 0.2)
0103:         time = st.slider("Time to Expiry (Years)", 0.1, 2.0, 1.0)
0104:     
0105:     # Calculate and display Greeks
0106:     call_greeks = model.calculate_greeks(spot, strike, 0.05, vol, time, "call")
0107:     put_greeks = model.calculate_greeks(spot, strike, 0.05, vol, time, "put")
0108:     
0109:     st.subheader("Call Option Greeks")
0110:     cols = st.columns(len(call_greeks))
0111:     for col, (greek, value) in zip(cols, call_greeks.items()):
0112:         col.metric(greek.capitalize(), f"{value:.4f}")
0113:     
0114:     # Add explanations for each Greek
0115:     st.markdown("""
0116:         ### Greek Interpretations:
0117:         
0118:         - **Delta**: Measures the rate of change in option price with respect to the underlying
0119:         - **Gamma**: Measures the rate of change in Delta
0120:         - **Theta**: Time decay; how much value is lost each day
0121:         - **Vega**: Sensitivity to volatility changes
0122:         - **Rho**: Sensitivity to interest rate changes
0123:     """)
0124: 
0125: def _render_strategy_education():
0126:     """Render options strategy education content."""
0127:     st.subheader("Common Options Strategies")
0128:     
0129:     strategy = st.selectbox(
0130:         "Select Strategy to Learn About",
0131:         ["Bull Call Spread", "Iron Condor", "Covered Call", "Protective Put"]
0132:     )
0133:     
0134:     # Display strategy details and interactive example
0135:     if strategy == "Bull Call Spread":
0136:         st.markdown("""
0137:             A Bull Call Spread involves:
0138:             1. Buying a call option
0139:             2. Selling another call option with a higher strike
0140:             
0141:             This strategy is used when you:
0142:             - Are moderately bullish
0143:             - Want to reduce cost
0144:             - Accept limited profit potential
0145:         """)
0146:         
0147:         # Interactive example
0148:         lower_strike = st.slider("Lower Strike", 90, 110, 100)
0149:         upper_strike = st.slider("Upper Strike", lower_strike, 120, lower_strike + 5)
0150:         
0151:         # Create positions for visualization
0152:         positions = [
0153:             Position("call", lower_strike, 1.0, 1, 100.0, 0.2, 0.05),
0154:             Position("call", upper_strike, 1.0, -1, 100.0, 0.2, 0.05)
0155:         ]
0156:         
0157:         # Display payoff diagram
0158:         payoff_chart = OptionPayoffChart()
0159:         fig = payoff_chart.create_payoff_chart(positions)
0160:         st.plotly_chart(fig)
0161: 
0162: # src/ui/pages/education.py (continued)
0163: 
0164: def _render_risk_management():
0165:     """Render comprehensive risk management education content."""
0166:     st.subheader("Portfolio Risk Management")
0167:     
0168:     st.markdown("""
0169:         Understanding risk management is crucial for successful options trading. Let's explore
0170:         the key concepts through interactive examples and practical scenarios.
0171:         
0172:         Risk management in options trading requires a multi-faceted approach that considers
0173:         both market risks and position-specific characteristics. We'll examine each aspect
0174:         and learn how to implement effective risk controls.
0175:     """)
0176:     
0177:     # Risk concept selection
0178:     risk_topic = st.selectbox(
0179:         "Select Risk Management Topic",
0180:         ["Position Sizing", "Greek Exposure Management", "Portfolio Diversification", 
0181:          "Volatility Risk", "Black Swan Events"]
0182:     )
0183:     
0184:     if risk_topic == "Position Sizing":
0185:         _render_position_sizing_lesson()
0186:     elif risk_topic == "Greek Exposure Management":
0187:         _render_greek_management_lesson()
0188:     elif risk_topic == "Portfolio Diversification":
0189:         _render_diversification_lesson()
0190:     elif risk_topic == "Volatility Risk":
0191:         _render_volatility_risk_lesson()
0192:     else:
0193:         _render_black_swan_lesson()
0194: 
0195: def _render_position_sizing_lesson():
0196:     """Teach position sizing principles through interactive examples."""
0197:     st.markdown("""
0198:         ### Position Sizing in Options Trading
0199:         
0200:         Position sizing is one of the most critical aspects of risk management. Proper
0201:         position sizing helps protect your portfolio from unexpected market moves while
0202:         allowing for meaningful profits when your analysis is correct.
0203:     """)
0204:     
0205:     # Interactive position sizing calculator
0206:     st.subheader("Position Size Calculator")
0207:     
0208:     col1, col2 = st.columns(2)
0209:     with col1:
0210:         account_size = st.number_input(
0211:             "Account Size ($)",
0212:             min_value=1000.0,
0213:             value=100000.0,
0214:             step=1000.0,
0215:             help="Your total trading account size"
0216:         )
0217:         
0218:         risk_percentage = st.slider(
0219:             "Risk Per Trade (%)",
0220:             min_value=0.1,
0221:             max_value=5.0,
0222:             value=1.0,
0223:             help="Maximum percentage of account to risk on this trade"
0224:         )
0225:     
0226:     with col2:
0227:         option_premium = st.number_input(
0228:             "Option Premium ($)",
0229:             min_value=0.1,
0230:             value=2.5,
0231:             step=0.1,
0232:             help="Cost of one option contract"
0233:         )
0234:         
0235:         contract_multiplier = st.number_input(
0236:             "Contract Multiplier",
0237:             min_value=1,
0238:             value=100,
0239:             step=1,
0240:             help="Standard equity option multiplier is 100"
0241:         )
0242:     
0243:     # Calculate and display position sizing recommendations
0244:     max_risk_amount = account_size * (risk_percentage / 100)
0245:     max_contracts = int(max_risk_amount / (option_premium * contract_multiplier))
0246:     
0247:     st.markdown(f"""
0248:         Based on your inputs:
0249:         
0250:         - Maximum risk amount: ${max_risk_amount:,.2f}
0251:         - Maximum number of contracts: {max_contracts}
0252:         - Total premium cost: ${(max_contracts * option_premium * contract_multiplier):,.2f}
0253:         
0254:         ### Position Sizing Guidelines
0255:         
0256:         When determining position size, consider:
0257:         
0258:         1. **Account Risk**: Never risk more than 1-2% of your account on a single trade
0259:         2. **Correlation Risk**: Reduce position size when trading correlated assets
0260:         3. **Volatility Adjustment**: Use smaller sizes in high volatility environments
0261:         4. **Liquidity Considerations**: Ensure you can exit the position easily
0262:     """)
0263:     
0264:     # Interactive scenario analysis
0265:     st.subheader("Scenario Analysis")
0266:     price_change = st.slider(
0267:         "Simulate Price Change (%)",
0268:         min_value=-50,
0269:         max_value=50,
0270:         value=0
0271:     )
0272:     
0273:     # Calculate scenario outcomes
0274:     position_value = max_contracts * option_premium * contract_multiplier
0275:     value_change = position_value * (price_change / 100)
0276:     new_account_value = account_size + value_change
0277:     
0278:     col1, col2, col3 = st.columns(3)
0279:     col1.metric("Position P&L", f"${value_change:,.2f}")
0280:     col2.metric("Account Change", f"{(value_change/account_size)*100:.1f}%")
0281:     col3.metric("New Account Value", f"${new_account_value:,.2f}")
0282: 
0283: def _render_greek_management_lesson():
0284:     """Teach Greek exposure management through interactive scenarios."""
0285:     st.markdown("""
0286:         ### Managing Greek Exposures
0287:         
0288:         Greek exposures represent different dimensions of option risk. Understanding
0289:         and managing these exposures is crucial for maintaining a balanced portfolio.
0290:     """)
0291:     
0292:     # Interactive Greek exposure simulator
0293:     st.subheader("Greek Exposure Simulator")
0294:     
0295:     # Create sample portfolio
0296:     portfolio = [
0297:         Position("call", 100, 1.0, 1, 100.0, 0.2, 0.05),
0298:         Position("put", 95, 1.0, -2, 100.0, 0.2, 0.05),
0299:         Position("call", 105, 1.0, -1, 100.0, 0.2, 0.05)
0300:     ]
0301:     
0302:     # Allow users to modify market parameters
0303:     col1, col2 = st.columns(2)
0304:     with col1:
0305:         price_change = st.slider(
0306:             "Price Change (%)",
0307:             min_value=-20,
0308:             max_value=20,
0309:             value=0
0310:         )
0311:         vol_change = st.slider(
0312:             "Volatility Change (%)",
0313:             min_value=-50,
0314:             max_value=50,
0315:             value=0
0316:         )
0317:     
0318:     with col2:
0319:         days_passed = st.slider(
0320:             "Days Passed",
0321:             min_value=0,
0322:             max_value=30,
0323:             value=0
0324:         )
0325:         rate_change = st.slider(
0326:             "Rate Change (bps)",
0327:             min_value=-50,
0328:             max_value=50,
0329:             value=0
0330:         )
0331:     
0332:     # Calculate and display risk metrics under different scenarios
0333:     model = BlackScholesModel()
0334:     original_value = sum(model.price_call(p.underlying_price, p.strike, p.risk_free_rate, 
0335:                                         p.volatility, p.expiry).price * p.quantity 
0336:                         for p in portfolio if p.option_type == "call") + \
0337:                     sum(model.price_put(p.underlying_price, p.strike, p.risk_free_rate,
0338:                                       p.volatility, p.expiry).price * p.quantity 
0339:                         for p in portfolio if p.option_type == "put")
0340:     
0341:     # Calculate new portfolio value under scenario
0342:     new_portfolio = [
0343:         Position(
0344:             p.option_type,
0345:             p.strike,
0346:             p.expiry - days_passed/365,
0347:             p.quantity,
0348:             p.underlying_price * (1 + price_change/100),
0349:             p.volatility * (1 + vol_change/100),
0350:             p.risk_free_rate + rate_change/10000
0351:         )
0352:         for p in portfolio
0353:     ]
0354:     
0355:     new_value = sum(model.price_call(p.underlying_price, p.strike, p.risk_free_rate,
0356:                                    p.volatility, p.expiry).price * p.quantity 
0357:                    for p in new_portfolio if p.option_type == "call") + \
0358:                 sum(model.price_put(p.underlying_price, p.strike, p.risk_free_rate,
0359:                                   p.volatility, p.expiry).price * p.quantity 
0360:                    for p in new_portfolio if p.option_type == "put")
0361:     
0362:     # Display scenario analysis results
0363:     st.subheader("Scenario Analysis Results")
0364:     
0365:     col1, col2, col3 = st.columns(3)
0366:     col1.metric("Portfolio P&L", f"${new_value - original_value:,.2f}")
0367:     col2.metric("Percentage Change", f"{((new_value/original_value - 1) * 100):.1f}%")
0368:     col3.metric("New Portfolio Value", f"${new_value:,.2f}")
0369:     
0370:     st.markdown("""
0371:         ### Key Lessons in Greek Management
0372:         
0373:         1. **Delta Management**:
0374:            - Keep overall portfolio delta aligned with your market view
0375:            - Consider using delta hedging for neutral strategies
0376:         
0377:         2. **Gamma Risk**:
0378:            - High gamma means rapid delta changes
0379:            - Reduce gamma exposure near major events
0380:         
0381:         3. **Theta Decay**:
0382:            - Time decay accelerates near expiration
0383:            - Balance positive and negative theta positions
0384:         
0385:         4. **Vega Exposure**:
0386:            - Manage volatility exposure across different strikes and expirations
0387:            - Consider VIX products for volatility hedging
0388:     """)
0389: 
0390: def _render_diversification_lesson():
0391:     """Teach portfolio diversification principles through interactive examples."""
0392:     st.markdown("""
0393:         ### Understanding Portfolio Diversification in Options Trading
0394:         
0395:         Portfolio diversification in options trading goes beyond simply trading different 
0396:         underlying assets. It involves managing exposures across multiple dimensions:
0397:         
0398:         - Different underlyings
0399:         - Various expiration dates
0400:         - Multiple strike prices
0401:         - Different option strategies
0402:         - Varied market conditions
0403:         
0404:         Let's explore how to build a well-diversified options portfolio through 
0405:         practical examples.
0406:     """)
0407:     
0408:     # Interactive portfolio builder
0409:     st.subheader("Portfolio Diversification Simulator")
0410:     
0411:     # Allow users to construct a sample portfolio
0412:     col1, col2 = st.columns(2)
0413:     with col1:
0414:         num_positions = st.slider(
0415:             "Number of Positions",
0416:             min_value=1,
0417:             max_value=10,
0418:             value=3,
0419:             help="More positions can provide better diversification, but may increase complexity"
0420:         )
0421:         
0422:         correlation = st.slider(
0423:             "Average Correlation Between Positions",
0424:             min_value=-1.0,
0425:             max_value=1.0,
0426:             value=0.3,
0427:             help="Higher correlation means less diversification benefit"
0428:         )
0429:     
0430:     with col2:
0431:         strategy_mix = st.multiselect(
0432:             "Strategy Types",
0433:             ["Directional", "Neutral", "Volatility", "Income"],
0434:             default=["Directional"],
0435:             help="Different strategy types can provide strategic diversification"
0436:         )
0437:         
0438:         market_scenarios = st.multiselect(
0439:             "Market Scenarios to Test",
0440:             ["Bull Market", "Bear Market", "High Volatility", "Low Volatility"],
0441:             default=["Bull Market", "Bear Market"]
0442:         )
0443:     
0444:     # Calculate and display diversification metrics
0445:     portfolio_risk = calculate_portfolio_metrics(num_positions, correlation)
0446:     
0447:     st.markdown("### Portfolio Risk Analysis")
0448:     col1, col2, col3 = st.columns(3)
0449:     
0450:     col1.metric(
0451:         "Portfolio Risk",
0452:         f"{portfolio_risk:.1f}%",
0453:         help="Lower numbers indicate better diversification"
0454:     )
0455:     col2.metric(
0456:         "Diversification Score",
0457:         f"{(1 - correlation) * 100:.1f}/100",
0458:         help="Higher scores indicate better diversification"
0459:     )
0460:     col3.metric(
0461:         "Strategy Coverage",
0462:         f"{len(strategy_mix)}/4",
0463:         help="More strategy types can improve resilience"
0464:     )
0465:     
0466:     # Show scenario analysis
0467:     st.subheader("Scenario Analysis")
0468:     _display_scenario_analysis(market_scenarios, strategy_mix, portfolio_risk)
0469: 
0470: def _render_volatility_risk_lesson():
0471:     """Teach volatility risk management with interactive examples."""
0472:     st.markdown("""
0473:         ### Managing Volatility Risk in Options Trading
0474:         
0475:         Volatility is a crucial factor in options pricing and risk management. Unlike 
0476:         stocks, options are affected by both price movement (directional risk) and 
0477:         changes in expected volatility (volatility risk).
0478:         
0479:         Understanding and managing volatility risk involves:
0480:         1. Measuring volatility exposure
0481:         2. Understanding volatility term structure
0482:         3. Managing vega risk
0483:         4. Implementing volatility trading strategies
0484:     """)
0485:     
0486:     # Interactive volatility analysis tool
0487:     st.subheader("Volatility Risk Calculator")
0488:     
0489:     col1, col2 = st.columns(2)
0490:     with col1:
0491:         current_iv = st.slider(
0492:             "Current Implied Volatility (%)",
0493:             min_value=10,
0494:             max_value=100,
0495:             value=30,
0496:             help="Current implied volatility level"
0497:         )
0498:         
0499:         position_vega = st.number_input(
0500:             "Position Vega",
0501:             min_value=-1000.0,
0502:             max_value=1000.0,
0503:             value=100.0,
0504:             help="Total portfolio vega exposure"
0505:         )
0506:     
0507:     with col2:
0508:         vol_change = st.slider(
0509:             "Volatility Change (%)",
0510:             min_value=-50,
0511:             max_value=50,
0512:             value=0,
0513:             help="Simulate a change in implied volatility"
0514:         )
0515:         
0516:         position_value = st.number_input(
0517:             "Position Value ($)",
0518:             min_value=0.0,
0519:             value=10000.0,
0520:             help="Current total position value"
0521:         )
0522:     
0523:     # Calculate impact of volatility changes
0524:     vol_pnl = calculate_volatility_pnl(position_vega, vol_change, position_value)
0525:     
0526:     # Display volatility risk metrics
0527:     st.markdown("### Volatility Risk Impact")
0528:     col1, col2, col3 = st.columns(3)
0529:     
0530:     col1.metric(
0531:         "P&L Impact",
0532:         f"${vol_pnl:,.2f}",
0533:         f"{(vol_pnl/position_value)*100:.1f}%"
0534:     )
0535:     col2.metric(
0536:         "New Position Value",
0537:         f"${position_value + vol_pnl:,.2f}"
0538:     )
0539:     col3.metric(
0540:         "New Implied Vol",
0541:         f"{current_iv + vol_change:.1f}%",
0542:         f"{vol_change:+.1f}%"
0543:     )
0544: 
0545: def _render_black_swan_lesson():
0546:     """Teach preparation for extreme market events."""
0547:     st.markdown("""
0548:         ### Preparing for Black Swan Events
0549:         
0550:         Black swan events are rare, unexpected occurrences that can have severe market 
0551:         impacts. While we cannot predict these events, we can prepare our portfolios 
0552:         to be more resilient when they occur.
0553:         
0554:         Let's explore strategies to protect against extreme market movements and 
0555:         volatility spikes.
0556:     """)
0557:     
0558:     # Interactive tail risk analysis
0559:     st.subheader("Tail Risk Simulator")
0560:     
0561:     col1, col2 = st.columns(2)
0562:     with col1:
0563:         protection_level = st.slider(
0564:             "Protection Level (%)",
0565:             min_value=0,
0566:             max_value=100,
0567:             value=20,
0568:             help="Percentage of portfolio protected against extreme events"
0569:         )
0570:         
0571:         hedge_type = st.selectbox(
0572:             "Hedge Type",
0573:             ["Put Options", "VIX Calls", "Tail Risk Hedge Fund", "Mixed Strategy"]
0574:         )
0575:     
0576:     with col2:
0577:         market_drop = st.slider(
0578:             "Market Drop Scenario (%)",
0579:             min_value=-75,
0580:             max_value=0,
0581:             value=-30,
0582:             help="Simulate a severe market decline"
0583:         )
0584:         
0585:         vol_spike = st.slider(
0586:             "Volatility Spike (%)",
0587:             min_value=0,
0588:             max_value=500,
0589:             value=150,
0590:             help="Simulate a volatility spike during market stress"
0591:         )
0592:     
0593:     # Calculate impact of black swan event
0594:     portfolio_impact = calculate_black_swan_impact(
0595:         protection_level, hedge_type, market_drop, vol_spike
0596:     )
0597:     
0598:     # Display protection analysis
0599:     st.markdown("### Protection Analysis")
0600:     col1, col2, col3 = st.columns(3)
0601:     
0602:     col1.metric(
0603:         "Unhedged Loss",
0604:         f"{portfolio_impact['unhedged']:,.1f}%"
0605:     )
0606:     col2.metric(
0607:         "Hedged Loss",
0608:         f"{portfolio_impact['hedged']:,.1f}%"
0609:     )
0610:     col3.metric(
0611:         "Hedge Effectiveness",
0612:         f"{portfolio_impact['effectiveness']:,.1f}%"
0613:     )
0614:     
0615:     st.markdown("""
0616:         ### Key Principles for Black Swan Protection
0617:         
0618:         1. **Diversification Beyond Correlation**
0619:            - Standard correlations break down in extreme events
0620:            - Need genuine strategy diversification
0621:            - Consider anti-correlation assets
0622:         
0623:         2. **Positive Convexity**
0624:            - Look for asymmetric payoff profiles
0625:            - Small cost for large potential protection
0626:            - Options-based strategies can provide convexity
0627:         
0628:         3. **Liquidity Management**
0629:            - Maintain adequate cash reserves
0630:            - Understand position liquidity under stress
0631:            - Plan exit strategies in advance
0632:         
0633:         4. **Regular Stress Testing**
0634:            - Test portfolio under extreme scenarios
0635:            - Consider multiple risk factors simultaneously
0636:            - Update protection strategies based on results
0637:     """)
0638: 
0639: # Helper functions for calculations
0640: 
0641: def calculate_portfolio_metrics(num_positions: int, correlation: float) -> float:
0642:     """Calculate portfolio risk metrics based on position count and correlation."""
0643:     # Simple portfolio risk calculation considering diversification effects
0644:     individual_risk = 20.0  # Assume 20% risk per position
0645:     portfolio_risk = individual_risk * np.sqrt(
0646:         (1/num_positions) + ((num_positions-1)/num_positions) * correlation
0647:     )
0648:     return portfolio_risk
0649: 
0650: def calculate_volatility_pnl(vega: float, vol_change: float, position_value: float) -> float:
0651:     """Calculate P&L impact from volatility changes."""
0652:     # Convert percentage change to volatility points
0653:     vol_point_change = vol_change / 100
0654:     
0655:     # Calculate P&L impact
0656:     vol_pnl = vega * vol_point_change
0657:     return vol_pnl
0658: 
0659: def calculate_black_swan_impact(protection: float, hedge_type: str, 
0660:                               market_drop: float, vol_spike: float) -> dict:
0661:     """Calculate portfolio impact under black swan scenarios."""
0662:     # Base impact from market drop
0663:     unhedged_impact = market_drop
0664:     
0665:     # Calculate hedge effectiveness based on type
0666:     hedge_effectiveness = {
0667:         "Put Options": 0.8,
0668:         "VIX Calls": 0.9,
0669:         "Tail Risk Hedge Fund": 0.7,
0670:         "Mixed Strategy": 0.85
0671:     }
0672:     
0673:     # Calculate protected portion
0674:     protection_ratio = protection / 100
0675:     effectiveness = hedge_effectiveness[hedge_type]
0676:     
0677:     hedged_impact = (market_drop * (1 - protection_ratio)) + \
0678:                    (market_drop * protection_ratio * (1 - effectiveness))
0679:     
0680:     return {
0681:         "unhedged": unhedged_impact,
0682:         "hedged": hedged_impact,
0683:         "effectiveness": (unhedged_impact - hedged_impact) / unhedged_impact * 100
0684:     }
0685: 
0686: def _display_scenario_analysis(scenarios: List[str], strategies: List[str], 
0687:                              base_risk: float):
0688:     """Display scenario analysis results for different market conditions."""
0689:     # Create scenario matrix
0690:     results = []
0691:     for scenario in scenarios:
0692:         scenario_results = []
0693:         for strategy in strategies:
0694:             # Calculate strategy performance in scenario
0695:             perf = _calculate_strategy_scenario(strategy, scenario, base_risk)
0696:             scenario_results.append(perf)
0697:         results.append(scenario_results)
0698:     
0699:     # Display results as a heatmap
0700:     fig = go.Figure(data=go.Heatmap(
0701:         z=results,
0702:         x=strategies,
0703:         y=scenarios,
0704:         colorscale='RdYlGn',
0705:         text=[[f"{x:.1f}%" for x in row] for row in results],
0706:         texttemplate="%{text}",
0707:         textfont={"size":10},
0708:         colorbar=dict(title="Returns")
0709:     ))
0710:     
0711:     fig.update_layout(
0712:         title="Strategy Performance Across Scenarios",
0713:         xaxis_title="Strategy Type",
0714:         yaxis_title="Market Scenario"
0715:     )
0716:     
0717:     st.plotly_chart(fig)

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\pages\home.py
// ----------------------------------------
0001: # src/ui/pages/home.py
0002: 
0003: import streamlit as st
0004: from datetime import datetime
0005: 
0006: def render_page():
0007:     """Render the educational home page."""
0008:     st.markdown(
0009:         """
0010:         # Learn Options Trading Interactively
0011:         
0012:         Welcome to your interactive options learning journey! This tool helps you understand:
0013:         
0014:         - Core options concepts through hands-on examples
0015:         - How different pricing models work and compare
0016:         - Option strategies and when to use them
0017:         - The Greeks and risk management
0018:         """
0019:     )
0020:     
0021:     # Display concept of the day
0022:     st.subheader("Today's Learning Concept")
0023:     concepts = {
0024:         0: ("Delta", "Learn how delta measures an option's directional exposure"),
0025:         1: ("Time Decay", "Understand how options lose value as expiration approaches"),
0026:         2: ("Implied Volatility", "Explore how market prices imply future volatility"),
0027:         3: ("Put-Call Parity", "Discover the fundamental relationship between puts and calls"),
0028:         4: ("Option Strategies", "Study common option combinations and their uses")
0029:     }
0030:     day_of_year = datetime.now().timetuple().tm_yday
0031:     concept, description = concepts[day_of_year % len(concepts)]
0032:     
0033:     st.info(f"📚 **{concept}**: {description}")
0034:     if st.button("Explore This Concept"):
0035:         st.session_state.selected_concept = concept
0036:     
0037:     # Quick start sections
0038:     col1, col2 = st.columns(2)
0039:     
0040:     with col1:
0041:         st.subheader("Start Learning")
0042:         st.markdown("""
0043:             Choose your path:
0044:             
0045:             1. **Beginner Track**
0046:                - Options Basics
0047:                - Understanding Calls and Puts
0048:                - Basic Strategies
0049:             
0050:             2. **Intermediate Track**
0051:                - The Greeks
0052:                - Volatility and Pricing
0053:                - Spreads and Combinations
0054:             
0055:             3. **Advanced Track**
0056:                - Advanced Strategies
0057:                - Pricing Models Deep Dive
0058:                - Volatility Trading
0059:         """)
0060:         
0061:         track = st.selectbox(
0062:             "Select Your Track",
0063:             ["Beginner", "Intermediate", "Advanced"]
0064:         )
0065:         if st.button("Start Learning"):
0066:             st.session_state.selected_track = track
0067:     
0068:     with col2:
0069:         st.subheader("Interactive Tools")
0070:         st.markdown("""
0071:             Explore and experiment:
0072:             
0073:             - **Model Explorer**: Compare different pricing models
0074:             - **Strategy Builder**: Build and analyze strategies
0075:             - **Greeks Lab**: Interactive Greek exploration
0076:             - **Volatility Tools**: Understand implied volatility
0077:         """)
0078:         
0079:         tool = st.selectbox(
0080:             "Select a Tool",
0081:             ["Model Explorer", "Strategy Builder", "Greeks Lab", "Volatility Tools"]
0082:         )
0083:         if st.button("Launch Tool"):
0084:             st.session_state.selected_tool = tool
0085:     
0086:     # Learning progress
0087:     st.subheader("Your Learning Progress")
0088:     concepts_learned = st.session_state.get('concepts_learned', [])
0089:     
0090:     progress = len(concepts_learned) / 20  # Example: 20 total concepts
0091:     st.progress(progress)
0092:     st.markdown(f"**{len(concepts_learned)}** of 20 core concepts mastered")
0093:     
0094:     if concepts_learned:
0095:         st.markdown("Recently mastered concepts:")
0096:         for concept in concepts_learned[-3:]:
0097:             st.markdown(f"✅ {concept}")
0098:     
0099:     # Daily challenge
0100:     st.subheader("Daily Challenge")
0101:     challenges = {
0102:         0: "Calculate the break-even point for a call option",
0103:         1: "Explain how gamma changes as price moves",
0104:         2: "Build a collar strategy",
0105:         3: "Compare Black-Scholes vs Binomial prices",
0106:         4: "Analyze a straddle's volatility exposure"
0107:     }
0108:     challenge = challenges[day_of_year % len(challenges)]
0109:     
0110:     st.info(f"🎯 **Today's Challenge**: {challenge}")
0111:     if st.button("Try Challenge"):
0112:         st.session_state.selected_challenge = challenge
0113:     
0114:     # Learning tips
0115:     st.markdown("""
0116:         ---
0117:         ### 💡 Learning Tips
0118:         
0119:         - Start with the fundamentals before advancing
0120:         - Use interactive tools to experiment with concepts
0121:         - Complete daily challenges to reinforce learning
0122:         - Review mastered concepts periodically
0123:     """)

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\pages\option_pricing.py
// ----------------------------------------
0001: # src/ui/pages/option_pricing.py
0002: import streamlit as st
0003: from src.ui.components.option_inputs import OptionInputs # Relative import (still works within the same package)
0004: from src.models.black_scholes import BlackScholesModel # Relative import (still works within the same package)
0005: 
0006: def render_page():
0007:     """Render the option pricing analysis page."""
0008:     st.header("Option Pricing Analysis")
0009:     
0010:     # Create option inputs component
0011:     inputs = OptionInputs()
0012:     parameters = inputs.render()
0013:     
0014:     # Model selection
0015:     model = st.selectbox(
0016:         "Pricing Model",
0017:         ["Black-Scholes", "Binomial", "Monte Carlo"]
0018:     )
0019:     
0020:     # Calculate option price
0021:     pricing_model = BlackScholesModel()  # Or other model based on selection
0022:     if parameters.option_type == "call":
0023:         result = pricing_model.price_call(
0024:             parameters.underlying_price,
0025:             parameters.strike_price,
0026:             parameters.risk_free_rate,
0027:             parameters.volatility,
0028:             parameters.time_to_expiry
0029:         )
0030:     else:
0031:         result = pricing_model.price_put(
0032:             parameters.underlying_price,
0033:             parameters.strike_price,
0034:             parameters.risk_free_rate,
0035:             parameters.volatility,
0036:             parameters.time_to_expiry
0037:         )
0038:     
0039:     # Display results
0040:     st.subheader("Option Price")
0041:     st.metric(
0042:         label="Price",
0043:         value=f"${result.price:.2f}"
0044:     )
0045:     
0046:     if result.greeks:
0047:         st.subheader("Greeks")
0048:         cols = st.columns(len(result.greeks))
0049:         for col, (greek, value) in zip(cols, result.greeks.items()):
0050:             col.metric(greek.capitalize(), f"{value:.4f}")

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\ui\pages\portfolio.py
// ----------------------------------------
0001: # src/ui/pages/portfolio.py
0002: 
0003: import streamlit as st
0004: import pandas as pd
0005: from typing import List
0006: from src.ui.components.portfolio_table import PortfolioTable # Relative import (still works within the same package)
0007: from src.ui.components.charts import OptionPayoffChart # Relative import (still works within the same package)
0008: from src.analytics.risk import Position, RiskAnalyzer # Relative import (still works within the same package)
0009: from src.models.black_scholes import BlackScholesModel # Relative import (still works within the same package)
0010: 
0011: def render_page():
0012:     """
0013:     Render the portfolio management and analysis page.
0014:     
0015:     This page allows users to:
0016:     1. Add and manage positions
0017:     2. View portfolio analytics
0018:     3. Analyze risk metrics
0019:     4. Visualize portfolio characteristics
0020:     """
0021:     st.header("Portfolio Management")
0022: 
0023:     # Portfolio input method selection
0024:     input_method = st.radio(
0025:         "Input Method",
0026:         ["Manual Entry", "Upload Positions", "Sample Portfolio"],
0027:         horizontal=True
0028:     )
0029: 
0030:     if input_method == "Manual Entry":
0031:         _render_manual_entry()
0032:     elif input_method == "Upload Positions":
0033:         _render_file_upload()
0034:     else:
0035:         _render_sample_portfolio()
0036: 
0037:     # Display portfolio analysis if positions exist
0038:     if 'portfolio_positions' in st.session_state and st.session_state.portfolio_positions:
0039:         _render_portfolio_analysis()
0040: 
0041: def _render_manual_entry():
0042:     """Render manual position entry form."""
0043:     with st.expander("Add New Position", expanded=True):
0044:         col1, col2 = st.columns(2)
0045:         
0046:         with col1:
0047:             option_type = st.selectbox("Option Type", ["Call", "Put"])
0048:             strike = st.number_input("Strike Price", min_value=0.01, value=100.0)
0049:             expiry = st.slider("Time to Expiry (Years)", 0.1, 2.0, 1.0)
0050:         
0051:         with col2:
0052:             quantity = st.number_input("Quantity", value=1, step=1)
0053:             underlying = st.number_input("Underlying Price", min_value=0.01, value=100.0)
0054:             volatility = st.slider("Volatility", 0.1, 1.0, 0.2)
0055: 
0056:         if st.button("Add Position"):
0057:             if 'portfolio_positions' not in st.session_state:
0058:                 st.session_state.portfolio_positions = []
0059:             
0060:             new_position = Position(
0061:                 option_type=option_type.lower(),
0062:                 strike=strike,
0063:                 expiry=expiry,
0064:                 quantity=quantity,
0065:                 underlying_price=underlying,
0066:                 volatility=volatility,
0067:                 risk_free_rate=0.05  # Default value
0068:             )
0069:             
0070:             st.session_state.portfolio_positions.append(new_position)
0071:             st.success("Position added successfully!")
0072: 
0073: def _render_file_upload():
0074:     """Handle portfolio file upload."""
0075:     uploaded_file = st.file_uploader(
0076:         "Upload Portfolio CSV",
0077:         type=['csv'],
0078:         help="CSV with columns: Type,Strike,Expiry,Quantity,Underlying,Volatility"
0079:     )
0080:     
0081:     if uploaded_file:
0082:         try:
0083:             df = pd.read_csv(uploaded_file)
0084:             required_columns = ['Type', 'Strike', 'Expiry', 'Quantity', 
0085:                               'Underlying', 'Volatility']
0086:             
0087:             if not all(col in df.columns for col in required_columns):
0088:                 st.error("CSV file must contain all required columns")
0089:                 return
0090:             
0091:             positions = []
0092:             for _, row in df.iterrows():
0093:                 position = Position(
0094:                     option_type=row['Type'].lower(),
0095:                     strike=row['Strike'],
0096:                     expiry=row['Expiry'],
0097:                     quantity=row['Quantity'],
0098:                     underlying_price=row['Underlying'],
0099:                     volatility=row['Volatility'],
0100:                     risk_free_rate=0.05
0101:                 )
0102:                 positions.append(position)
0103:             
0104:             st.session_state.portfolio_positions = positions
0105:             st.success("Portfolio loaded successfully!")
0106:         
0107:         except Exception as e:
0108:             st.error(f"Error loading portfolio: {str(e)}")
0109: 
0110: def _render_portfolio_analysis():
0111:     """Render portfolio analysis section."""
0112:     st.subheader("Portfolio Analysis")
0113: 
0114:     # Display current positions
0115:     portfolio_table = PortfolioTable(st.session_state.portfolio_positions)
0116:     portfolio_table.render()
0117: 
0118:     # Initialize risk analyzer with Black-Scholes model
0119:     risk_analyzer = RiskAnalyzer(BlackScholesModel())
0120: 
0121:     # Calculate risk metrics
0122:     risk_metrics = risk_analyzer.calculate_portfolio_risk(
0123:         st.session_state.portfolio_positions
0124:     )
0125: 
0126:     # Display risk metrics
0127:     col1, col2, col3 = st.columns(3)
0128:     with col1:
0129:         st.metric("Delta Exposure", f"{risk_metrics.delta_exposure:.2f}")
0130:     with col2:
0131:         st.metric("Value at Risk (95%)", f"${risk_metrics.value_at_risk:.2f}")
0132:     with col3:
0133:         st.metric("Expected Shortfall", f"${risk_metrics.expected_shortfall:.2f}")
0134: 
0135:     # Display payoff chart
0136:     payoff_chart = OptionPayoffChart()
0137:     fig = payoff_chart.create_payoff_chart(st.session_state.portfolio_positions)
0138:     st.plotly_chart(fig, use_container_width=True)
0139: 
0140:     # Stress test results
0141:     if risk_metrics.stress_scenarios:
0142:         st.subheader("Stress Test Results")
0143:         scenarios_df = pd.DataFrame.from_dict(
0144:             risk_metrics.stress_scenarios,
0145:             orient='index',
0146:             columns=['P&L Impact']
0147:         )
0148:         st.dataframe(scenarios_df)

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\utils\__init__.py
// ----------------------------------------

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\utils\cache.py
// ----------------------------------------
0001: """
0002: Cache utilities for optimizing expensive computations and data retrieval.
0003: 
0004: This module provides a flexible caching system with:
0005: 1. Memory and disk-based caching options
0006: 2. Configurable expiration and size limits
0007: 3. Automatic cache invalidation
0008: 4. Thread-safe operations
0009: 5. Monitoring and statistics
0010: """
0011: 
0012: import functools
0013: import threading
0014: import time
0015: import pickle
0016: import os
0017: from typing import Any, Dict, Optional, Tuple, Callable
0018: from datetime import datetime, timedelta
0019: import logging
0020: from pathlib import Path
0021: 
0022: logger = logging.getLogger(__name__)
0023: 
0024: class CacheStats:
0025:     """Tracks cache performance metrics."""
0026:     
0027:     def __init__(self):
0028:         self.hits = 0
0029:         self.misses = 0
0030:         self.evictions = 0
0031:         self._lock = threading.Lock()
0032:     
0033:     def record_hit(self):
0034:         with self._lock:
0035:             self.hits += 1
0036:     
0037:     def record_miss(self):
0038:         with self._lock:
0039:             self.misses += 1
0040:     
0041:     def record_eviction(self):
0042:         with self._lock:
0043:             self.evictions += 1
0044:     
0045:     @property
0046:     def hit_rate(self) -> float:
0047:         """Calculate cache hit rate."""
0048:         total = self.hits + self.misses
0049:         return self.hits / total if total > 0 else 0.0
0050:     
0051:     def __str__(self) -> str:
0052:         return (f"Cache Stats - Hits: {self.hits}, Misses: {self.misses}, "
0053:                 f"Evictions: {self.evictions}, Hit Rate: {self.hit_rate:.2%}")
0054: 
0055: class CacheEntry:
0056:     """Represents a single cache entry with metadata."""
0057:     
0058:     def __init__(self, value: Any, expiry: Optional[datetime] = None):
0059:         self.value = value
0060:         self.expiry = expiry
0061:         self.last_accessed = datetime.now()
0062:         self.access_count = 0
0063:     
0064:     def is_expired(self) -> bool:
0065:         """Check if the cache entry has expired."""
0066:         if self.expiry is None:
0067:             return False
0068:         return datetime.now() > self.expiry
0069:     
0070:     def access(self):
0071:         """Update entry metadata on access."""
0072:         self.last_accessed = datetime.now()
0073:         self.access_count += 1
0074: 
0075: class Cache:
0076:     """
0077:     Thread-safe cache implementation with memory and disk backing.
0078:     
0079:     Features:
0080:     - LRU eviction policy
0081:     - Time-based expiration
0082:     - Size limits
0083:     - Optional disk persistence
0084:     - Statistics tracking
0085:     """
0086:     
0087:     def __init__(self, max_size: int = 1000, 
0088:                  default_ttl: Optional[timedelta] = timedelta(hours=1),
0089:                  disk_path: Optional[Path] = None):
0090:         """
0091:         Initialize cache with configuration parameters.
0092:         
0093:         Args:
0094:             max_size: Maximum number of items to store
0095:             default_ttl: Default time-to-live for entries
0096:             disk_path: Optional path for disk persistence
0097:         """
0098:         self._cache: Dict[str, CacheEntry] = {}
0099:         self._lock = threading.Lock()
0100:         self.max_size = max_size
0101:         self.default_ttl = default_ttl
0102:         self.disk_path = disk_path
0103:         self.stats = CacheStats()
0104:         
0105:         # Create disk cache directory if needed
0106:         if disk_path:
0107:             disk_path.mkdir(parents=True, exist_ok=True)
0108:     
0109:     def get(self, key: str) -> Optional[Any]:
0110:         """
0111:         Retrieve a value from the cache.
0112:         
0113:         Thread-safe retrieval with automatic expiration handling.
0114:         """
0115:         with self._lock:
0116:             entry = self._cache.get(key)
0117:             
0118:             if entry is None:
0119:                 # Check disk cache if configured
0120:                 if self.disk_path:
0121:                     entry = self._load_from_disk(key)
0122:                 if entry is None:
0123:                     self.stats.record_miss()
0124:                     return None
0125:             
0126:             # Check expiration
0127:             if entry.is_expired():
0128:                 self._remove(key)
0129:                 self.stats.record_miss()
0130:                 return None
0131:             
0132:             # Update access metadata
0133:             entry.access()
0134:             self.stats.record_hit()
0135:             return entry.value
0136:     
0137:     def set(self, key: str, value: Any, ttl: Optional[timedelta] = None) -> None:
0138:         """
0139:         Store a value in the cache.
0140:         
0141:         Args:
0142:             key: Cache key
0143:             value: Value to store
0144:             ttl: Optional time-to-live override
0145:         """
0146:         with self._lock:
0147:             # Calculate expiry
0148:             expiry = None
0149:             if ttl or self.default_ttl:
0150:                 expiry = datetime.now() + (ttl or self.default_ttl)
0151:             
0152:             # Create entry
0153:             entry = CacheEntry(value, expiry)
0154:             
0155:             # Check size limit
0156:             if len(self._cache) >= self.max_size:
0157:                 self._evict_lru()
0158:             
0159:             # Store in memory
0160:             self._cache[key] = entry
0161:             
0162:             # Store to disk if configured
0163:             if self.disk_path:
0164:                 self._save_to_disk(key, entry)
0165:     
0166:     def invalidate(self, key: str) -> None:
0167:         """Remove a specific key from the cache."""
0168:         with self._lock:
0169:             self._remove(key)
0170:     
0171:     def clear(self) -> None:
0172:         """Clear all entries from the cache."""
0173:         with self._lock:
0174:             self._cache.clear()
0175:             if self.disk_path:
0176:                 for file in self.disk_path.glob("*.cache"):
0177:                     file.unlink()
0178:     
0179:     def _evict_lru(self) -> None:
0180:         """Evict least recently used entry."""
0181:         if not self._cache:
0182:             return
0183:         
0184:         # Find LRU entry
0185:         lru_key = min(self._cache.items(), 
0186:                      key=lambda x: x[1].last_accessed)[0]
0187:         
0188:         # Remove it
0189:         self._remove(lru_key)
0190:         self.stats.record_eviction()
0191:     
0192:     def _remove(self, key: str) -> None:
0193:         """Remove an entry from both memory and disk."""
0194:         self._cache.pop(key, None)
0195:         if self.disk_path:
0196:             cache_file = self.disk_path / f"{key}.cache"
0197:             if cache_file.exists():
0198:                 cache_file.unlink()
0199:     
0200:     def _save_to_disk(self, key: str, entry: CacheEntry) -> None:
0201:         """Save cache entry to disk."""
0202:         try:
0203:             cache_file = self.disk_path / f"{key}.cache"
0204:             with cache_file.open('wb') as f:
0205:                 pickle.dump(entry, f)
0206:         except Exception as e:
0207:             logger.error(f"Failed to save cache entry to disk: {e}")
0208:     
0209:     def _load_from_disk(self, key: str) -> Optional[CacheEntry]:
0210:         """Load cache entry from disk."""
0211:         try:
0212:             cache_file = self.disk_path / f"{key}.cache"
0213:             if not cache_file.exists():
0214:                 return None
0215:             
0216:             with cache_file.open('rb') as f:
0217:                 return pickle.load(f)
0218:         except Exception as e:
0219:             logger.error(f"Failed to load cache entry from disk: {e}")
0220:             return None
0221: 
0222: # Decorator for function-level caching
0223: def cached(ttl: Optional[timedelta] = None, 
0224:           key_prefix: str = "",
0225:           cache_instance: Optional[Cache] = None):
0226:     """
0227:     Decorator for caching function results.
0228:     
0229:     Args:
0230:         ttl: Optional time-to-live override
0231:         key_prefix: Optional prefix for cache keys
0232:         cache_instance: Optional specific cache instance to use
0233:     """
0234:     def decorator(func: Callable):
0235:         # Use provided cache or create a default one
0236:         nonlocal cache_instance
0237:         if cache_instance is None:
0238:             cache_instance = Cache()
0239:         
0240:         @functools.wraps(func)
0241:         def wrapper(*args, **kwargs):
0242:             # Generate cache key
0243:             key_parts = [key_prefix, func.__name__]
0244:             key_parts.extend(str(arg) for arg in args)
0245:             key_parts.extend(f"{k}={v}" for k, v in sorted(kwargs.items()))
0246:             cache_key = ":".join(key_parts)
0247:             
0248:             # Check cache
0249:             result = cache_instance.get(cache_key)
0250:             if result is not None:
0251:                 return result
0252:             
0253:             # Compute and cache result
0254:             result = func(*args, **kwargs)
0255:             cache_instance.set(cache_key, result, ttl)
0256:             return result
0257:         
0258:         return wrapper
0259:     return decorator
0260: 
0261: # Example usage
0262: if __name__ == "__main__":
0263:     # Create cache instance
0264:     cache = Cache(max_size=100, 
0265:                  default_ttl=timedelta(minutes=30),
0266:                  disk_path=Path("cache"))
0267:     
0268:     # Example cached function
0269:     @cached(ttl=timedelta(minutes=5), cache_instance=cache)
0270:     def expensive_computation(x: int, y: int) -> int:
0271:         time.sleep(1)  # Simulate expensive work
0272:         return x + y
0273:     
0274:     # Test caching
0275:     start = time.time()
0276:     result1 = expensive_computation(1, 2)
0277:     time1 = time.time() - start
0278:     
0279:     start = time.time()
0280:     result2 = expensive_computation(1, 2)  # Should be cached
0281:     time2 = time.time() - start
0282:     
0283:     print(f"First call: {time1:.2f}s")
0284:     print(f"Second call: {time2:.2f}s")
0285:     print(f"Cache stats: {cache.stats}")

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\utils\formatters.py
// ----------------------------------------
0001: """
0002: Formatting utilities for consistent data presentation.
0003: 
0004: This module provides formatting functions for:
0005: 1. Financial values (currency, percentages)
0006: 2. Option Greeks
0007: 3. Dates and times
0008: 4. Portfolio and position data
0009: 5. Statistical metrics
0010: """
0011: 
0012: import locale
0013: from datetime import datetime, date
0014: from typing import Union, Optional, Dict, Any
0015: from decimal import Decimal
0016: import re
0017: 
0018: # Set locale for currency formatting
0019: locale.setlocale(locale.LC_ALL, '')
0020: 
0021: class FinancialFormatter:
0022:     """Handles formatting of financial values."""
0023:     
0024:     @staticmethod
0025:     def currency(value: Union[float, Decimal], include_cents: bool = True) -> str:
0026:         """
0027:         Format a value as currency.
0028:         
0029:         Args:
0030:             value: The value to format
0031:             include_cents: Whether to include cents
0032:             
0033:         Returns:
0034:             Formatted currency string
0035:         """
0036:         try:
0037:             if include_cents:
0038:                 return locale.currency(float(value), grouping=True)
0039:             return locale.currency(float(value), grouping=True, digits=0)
0040:         except (ValueError, TypeError):
0041:             return "$0.00" if include_cents else "$0"
0042:     
0043:     @staticmethod
0044:     def percentage(value: Union[float, Decimal], decimals: int = 2) -> str:
0045:         """Format a value as a percentage."""
0046:         try:
0047:             return f"{float(value):.{decimals}f}%"
0048:         except (ValueError, TypeError):
0049:             return "0.00%"
0050:     
0051:     @staticmethod
0052:     def number(value: Union[float, Decimal], decimals: int = 2,
0053:               use_thousands: bool = True) -> str:
0054:         """Format a number with optional thousands separator."""
0055:         try:
0056:             value_float = float(value)
0057:             if use_thousands:
0058:                 return f"{value_float:,.{decimals}f}"
0059:             return f"{value_float:.{decimals}f}"
0060:         except (ValueError, TypeError):
0061:             return "0.00"
0062:     
0063:     @staticmethod
0064:     def delta_value(value: Union[float, Decimal], include_sign: bool = True) -> str:
0065:         """Format a delta (change) value with sign indicator."""
0066:         try:
0067:             value_float = float(value)
0068:             if include_sign and value_float > 0:
0069:                 return f"+{value_float:,.2f}"
0070:             return f"{value_float:,.2f}"
0071:         except (ValueError, TypeError):
0072:             return "+0.00" if include_sign else "0.00"
0073: 
0074: class GreeksFormatter:
0075:     """Handles formatting of option Greeks values."""
0076:     
0077:     @staticmethod
0078:     def delta(value: float) -> str:
0079:         """Format delta with appropriate precision."""
0080:         return f"{value:.3f}"
0081:     
0082:     @staticmethod
0083:     def gamma(value: float) -> str:
0084:         """Format gamma with appropriate precision."""
0085:         return f"{value:.4f}"
0086:     
0087:     @staticmethod
0088:     def theta(value: float) -> str:
0089:         """Format theta with appropriate precision."""
0090:         return f"{value:.2f}"
0091:     
0092:     @staticmethod
0093:     def vega(value: float) -> str:
0094:         """Format vega with appropriate precision."""
0095:         return f"{value:.2f}"
0096:     
0097:     @staticmethod
0098:     def rho(value: float) -> str:
0099:         """Format rho with appropriate precision."""
0100:         return f"{value:.3f}"
0101:     
0102:     @staticmethod
0103:     def format_all(greeks: Dict[str, float]) -> Dict[str, str]:
0104:         """Format all Greeks in a dictionary."""
0105:         formatters = {
0106:             'delta': GreeksFormatter.delta,
0107:             'gamma': GreeksFormatter.gamma,
0108:             'theta': GreeksFormatter.theta,
0109:             'vega': GreeksFormatter.vega,
0110:             'rho': GreeksFormatter.rho
0111:         }
0112:         
0113:         return {
0114:             greek: formatters.get(greek.lower(), str)(value)
0115:             for greek, value in greeks.items()
0116:         }
0117: 
0118: class DateFormatter:
0119:     """Handles formatting of dates and times."""
0120:     
0121:     @staticmethod
0122:     def format_date(d: Union[datetime, date], format_str: str = "%Y-%m-%d") -> str:
0123:         """Format a date with specified format string."""
0124:         try:
0125:             return d.strftime(format_str)
0126:         except AttributeError:
0127:             return ""
0128:     
0129:     @staticmethod
0130:     def format_expiry(expiry: Union[datetime, date, float]) -> str:
0131:         """
0132:         Format option expiry date/time.
0133:         
0134:         Handles both datetime objects and year fractions. Provides human-readable
0135:         relative time formats (e.g., "3d" for 3 days, "2w" for 2 weeks).
0136:         
0137:         Args:
0138:             expiry: Either a datetime/date object or a year fraction (e.g., 0.5 for 6 months)
0139:             
0140:         Returns:
0141:             Formatted expiry string in the most appropriate unit
0142:         """
0143:         if isinstance(expiry, (datetime, date)):
0144:             return expiry.strftime("%Y-%m-%d")
0145:         try:
0146:             # Convert year fraction to days
0147:             days = int(float(expiry) * 365)
0148:             if days <= 0:
0149:                 return "Expired"
0150:             if days < 7:
0151:                 return f"{days}d"
0152:             if days < 30:
0153:                 return f"{days//7}w"
0154:             if days < 365:
0155:                 return f"{days//30}m"
0156:             return f"{days//365}y"
0157:         except (ValueError, TypeError):
0158:             return "Invalid"
0159:     
0160:     @staticmethod
0161:     def timestamp_to_age(timestamp: Union[datetime, float]) -> str:
0162:         """
0163:         Convert a timestamp to a human-readable age string.
0164:         
0165:         This is useful for showing how long a position has been held or
0166:         when a trade was executed.
0167:         
0168:         Args:
0169:             timestamp: Either a datetime object or Unix timestamp
0170:             
0171:         Returns:
0172:             Human-readable age string (e.g., "2h ago", "3d ago")
0173:         """
0174:         try:
0175:             if isinstance(timestamp, float):
0176:                 dt = datetime.fromtimestamp(timestamp)
0177:             else:
0178:                 dt = timestamp
0179:             
0180:             delta = datetime.now() - dt
0181:             
0182:             # Convert timedelta to the most appropriate unit
0183:             seconds = delta.total_seconds()
0184:             if seconds < 60:
0185:                 return "just now"
0186:             if seconds < 3600:
0187:                 minutes = int(seconds / 60)
0188:                 return f"{minutes}m ago"
0189:             if seconds < 86400:
0190:                 hours = int(seconds / 3600)
0191:                 return f"{hours}h ago"
0192:             if seconds < 604800:
0193:                 days = int(seconds / 86400)
0194:                 return f"{days}d ago"
0195:             if seconds < 2592000:
0196:                 weeks = int(seconds / 604800)
0197:                 return f"{weeks}w ago"
0198:             if seconds < 31536000:
0199:                 months = int(seconds / 2592000)
0200:                 return f"{months}mo ago"
0201:             years = int(seconds / 31536000)
0202:             return f"{years}y ago"
0203:         except (ValueError, TypeError, AttributeError):
0204:             return "unknown"
0205: 
0206: class PortfolioFormatter:
0207:     """
0208:     Handles formatting of portfolio and position data with consistent styling.
0209:     
0210:     This class ensures that portfolio data is presented in a clear, consistent
0211:     manner across the application, making it easier for users to understand
0212:     their positions and risk exposure.
0213:     """
0214:     
0215:     @staticmethod
0216:     def format_position(position: Dict[str, Any]) -> Dict[str, str]:
0217:         """
0218:         Format a complete position entry with all relevant fields.
0219:         
0220:         This method provides consistent formatting for all position attributes,
0221:         ensuring that values are presented with appropriate precision and units.
0222:         
0223:         Args:
0224:             position: Dictionary containing position details
0225:             
0226:         Returns:
0227:             Dictionary with formatted position values
0228:         """
0229:         fin = FinancialFormatter()
0230:         greeks = GreeksFormatter()
0231:         dates = DateFormatter()
0232:         
0233:         # Create formatted position dictionary with proper precision and units
0234:         formatted = {
0235:             "type": position.get("option_type", "").upper(),
0236:             "strike": fin.currency(position.get("strike", 0)),
0237:             "expiry": dates.format_expiry(position.get("expiry", 0)),
0238:             "quantity": str(position.get("quantity", 0)),
0239:             "underlying": fin.currency(position.get("underlying_price", 0)),
0240:             "premium": fin.currency(position.get("premium", 0)),
0241:             "market_value": fin.currency(position.get("market_value", 0)),
0242:             "unrealized_pnl": fin.delta_value(position.get("unrealized_pnl", 0)),
0243:             "implied_vol": fin.percentage(position.get("volatility", 0)),
0244:             "days_held": dates.timestamp_to_age(position.get("entry_date", datetime.now()))
0245:         }
0246:         
0247:         # Add formatted Greeks if present
0248:         if "greeks" in position:
0249:             formatted.update(greeks.format_all(position["greeks"]))
0250:         
0251:         return formatted
0252:     
0253:     @staticmethod
0254:     def format_summary(summary: Dict[str, Any]) -> Dict[str, str]:
0255:         """
0256:         Format portfolio summary statistics.
0257:         
0258:         Provides consistent formatting for portfolio-level metrics,
0259:         making it easy to display summary information in the UI.
0260:         
0261:         Args:
0262:             summary: Dictionary containing portfolio summary data
0263:             
0264:         Returns:
0265:             Dictionary with formatted summary values
0266:         """
0267:         fin = FinancialFormatter()
0268:         
0269:         return {
0270:             "total_value": fin.currency(summary.get("total_value", 0)),
0271:             "daily_pnl": fin.delta_value(summary.get("daily_pnl", 0)),
0272:             "total_pnl": fin.delta_value(summary.get("total_pnl", 0)),
0273:             "daily_return": fin.percentage(summary.get("daily_return", 0)),
0274:             "total_return": fin.percentage(summary.get("total_return", 0)),
0275:             "realized_pnl": fin.delta_value(summary.get("realized_pnl", 0)),
0276:             "unrealized_pnl": fin.delta_value(summary.get("unrealized_pnl", 0)),
0277:             "margin_used": fin.currency(summary.get("margin_used", 0)),
0278:             "buying_power": fin.currency(summary.get("buying_power", 0))
0279:         }
0280: 
0281: class StatisticalFormatter:
0282:     """
0283:     Handles formatting of statistical metrics and analysis results.
0284:     
0285:     This class provides consistent formatting for various statistical measures
0286:     used in portfolio analysis and risk management.
0287:     """
0288:     
0289:     @staticmethod
0290:     def format_distribution_stats(stats: Dict[str, float]) -> Dict[str, str]:
0291:         """
0292:         Format statistical distribution metrics.
0293:         
0294:         Provides appropriate formatting for measures like mean, standard
0295:         deviation, skewness, and kurtosis.
0296:         
0297:         Args:
0298:             stats: Dictionary of statistical measures
0299:             
0300:         Returns:
0301:             Dictionary with formatted statistical values
0302:         """
0303:         fin = FinancialFormatter()
0304:         
0305:         return {
0306:             "mean": fin.number(stats.get("mean", 0), decimals=3),
0307:             "median": fin.number(stats.get("median", 0), decimals=3),
0308:             "std_dev": fin.number(stats.get("std_dev", 0), decimals=3),
0309:             "skewness": fin.number(stats.get("skewness", 0), decimals=3),
0310:             "kurtosis": fin.number(stats.get("kurtosis", 0), decimals=3),
0311:             "sharpe": fin.number(stats.get("sharpe", 0), decimals=2),
0312:             "sortino": fin.number(stats.get("sortino", 0), decimals=2),
0313:             "max_drawdown": fin.percentage(stats.get("max_drawdown", 0)),
0314:             "var_95": fin.currency(stats.get("var_95", 0)),
0315:             "cvar_95": fin.currency(stats.get("cvar_95", 0))
0316:         }
0317:     
0318:     @staticmethod
0319:     def format_correlation(value: float) -> str:
0320:         """
0321:         Format correlation coefficients with appropriate precision.
0322:         
0323:         Args:
0324:             value: Correlation coefficient (-1 to 1)
0325:             
0326:         Returns:
0327:             Formatted correlation string with color indicator
0328:         """
0329:         try:
0330:             value_float = float(value)
0331:             # Clamp value to valid range
0332:             value_float = max(-1.0, min(1.0, value_float))
0333:             return f"{value_float:+.2f}"
0334:         except (ValueError, TypeError):
0335:             return "0.00"
0336: 
0337: def format_table_value(value: Any, format_type: str = "default") -> str:
0338:     """
0339:     Generic formatter for table cell values.
0340:     
0341:     This utility function provides consistent formatting for values
0342:     displayed in tables throughout the application.
0343:     
0344:     Args:
0345:         value: The value to format
0346:         format_type: Type of formatting to apply
0347:         
0348:     Returns:
0349:         Formatted string ready for display
0350:     """
0351:     fin = FinancialFormatter()
0352:     
0353:     # Handle None/null values
0354:     if value is None:
0355:         return "-"
0356:     
0357:     # Apply formatting based on type
0358:     format_map = {
0359:         "currency": lambda x: fin.currency(float(x)),
0360:         "percentage": lambda x: fin.percentage(float(x)),
0361:         "number": lambda x: fin.number(float(x)),
0362:         "delta": lambda x: fin.delta_value(float(x)),
0363:         "date": lambda x: DateFormatter.format_date(x),
0364:         "expiry": lambda x: DateFormatter.format_expiry(x),
0365:         "age": lambda x: DateFormatter.timestamp_to_age(x)
0366:     }
0367:     
0368:     try:
0369:         if format_type in format_map:
0370:             return format_map[format_type](value)
0371:         return str(value)
0372:     except (ValueError, TypeError):
0373:         return "-"

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\utils\market_data.py
// ----------------------------------------
0001: """
0002: Market data handling and processing utilities.
0003: 
0004: This module provides robust functionality for:
0005: 1. Fetching market data from various sources
0006: 2. Rate limiting and error handling
0007: 3. Data normalization and validation
0008: 4. Caching and persistence
0009: """
0010: 
0011: import asyncio
0012: import aiohttp
0013: import yfinance as yf
0014: import pandas as pd
0015: import numpy as np
0016: from datetime import datetime, timedelta
0017: from typing import Dict, List, Optional, Union, Any
0018: import logging
0019: from pathlib import Path
0020: import json
0021: from dataclasses import dataclass
0022: import time
0023: import threading
0024: from concurrent.futures import ThreadPoolExecutor
0025: from src.utils.cache import Cache, cached
0026: from src.config import AppConfig
0027: 
0028: logger = logging.getLogger(__name__)
0029: 
0030: @dataclass
0031: class MarketQuote:
0032:     """Container for market data quotes."""
0033:     symbol: str
0034:     timestamp: datetime
0035:     bid: float
0036:     ask: float
0037:     last: float
0038:     volume: int
0039:     source: str
0040:     
0041:     @property
0042:     def mid(self) -> float:
0043:         """Calculate mid-point price."""
0044:         return (self.bid + self.ask) / 2 if self.bid and self.ask else self.last
0045:     
0046:     @property
0047:     def spread(self) -> float:
0048:         """Calculate bid-ask spread."""
0049:         return self.ask - self.bid if self.bid and self.ask else 0.0
0050: 
0051: @dataclass
0052: class OptionQuote(MarketQuote):
0053:     """Extended quote data for options."""
0054:     strike: float
0055:     expiry: datetime
0056:     option_type: str
0057:     underlying_price: float
0058:     implied_volatility: float
0059:     open_interest: int
0060:     delta: Optional[float] = None
0061:     gamma: Optional[float] = None
0062:     theta: Optional[float] = None
0063:     vega: Optional[float] = None
0064:     rho: Optional[float] = None
0065: 
0066: class RateLimiter:
0067:     """
0068:     Thread-safe rate limiter for API calls.
0069:     
0070:     This ensures we don't exceed API rate limits by implementing
0071:     token bucket algorithm with configurable rates.
0072:     """
0073:     
0074:     def __init__(self, max_requests: int, time_window: float):
0075:         """
0076:         Initialize rate limiter.
0077:         
0078:         Args:
0079:             max_requests: Maximum requests allowed in time window
0080:             time_window: Time window in seconds
0081:         """
0082:         self.max_requests = max_requests
0083:         self.time_window = time_window
0084:         self.tokens = max_requests
0085:         self.last_update = time.monotonic()
0086:         self._lock = threading.Lock()
0087:     
0088:     def acquire(self, tokens: int = 1) -> bool:
0089:         """
0090:         Attempt to acquire rate limit tokens.
0091:         
0092:         Args:
0093:             tokens: Number of tokens to acquire
0094:             
0095:         Returns:
0096:             True if tokens were acquired, False if would exceed rate limit
0097:         """
0098:         with self._lock:
0099:             now = time.monotonic()
0100:             time_passed = now - self.last_update
0101:             
0102:             # Replenish tokens based on time passed
0103:             self.tokens = min(
0104:                 self.max_requests,
0105:                 self.tokens + time_passed * (self.max_requests / self.time_window)
0106:             )
0107:             self.last_update = now
0108:             
0109:             if self.tokens >= tokens:
0110:                 self.tokens -= tokens
0111:                 return True
0112:             return False
0113:     
0114:     async def acquire_async(self, tokens: int = 1) -> None:
0115:         """
0116:         Asynchronously acquire rate limit tokens.
0117:         
0118:         This will wait until tokens become available.
0119:         """
0120:         while not self.acquire(tokens):
0121:             await asyncio.sleep(0.1)
0122: 
0123: class MarketDataClient:
0124:     """
0125:     Client for fetching market data from multiple sources.
0126:     
0127:     Features:
0128:     - Multiple data source support
0129:     - Automatic failover
0130:     - Rate limiting
0131:     - Caching
0132:     - Async batch operations
0133:     """
0134:     
0135:     def __init__(self, config: AppConfig):
0136:         """
0137:         Initialize market data client.
0138:         
0139:         Args:
0140:             config: Application configuration
0141:         """
0142:         self.config = config
0143:         self.cache = Cache(
0144:             max_size=1000,
0145:             default_ttl=timedelta(minutes=15),
0146:             disk_path=Path("cache/market_data")
0147:         )
0148:         
0149:         # Initialize rate limiters for different APIs
0150:         self.rate_limiters = {
0151:             "yahoo": RateLimiter(max_requests=2000, time_window=3600),  # 2000/hour
0152:             "alpha_vantage": RateLimiter(max_requests=5, time_window=60),  # 5/minute
0153:             "iex": RateLimiter(max_requests=100, time_window=60)  # 100/minute
0154:         }
0155:         
0156:         # Initialize async session
0157:         self._session = None
0158:         self._session_lock = threading.Lock()
0159:         self._executor = ThreadPoolExecutor(max_workers=4)
0160:     
0161:     async def _get_session(self) -> aiohttp.ClientSession:
0162:         """Get or create aiohttp session."""
0163:         if self._session is None:
0164:             async with self._session_lock:
0165:                 if self._session is None:
0166:                     self._session = aiohttp.ClientSession()
0167:         return self._session
0168:     
0169:     async def close(self):
0170:         """Close client and cleanup resources."""
0171:         if self._session:
0172:             await self._session.close()
0173:         self._executor.shutdown()
0174:     
0175:     async def get_quote(self, symbol: str, source: str = "yahoo") -> MarketQuote:
0176:         """
0177:         Fetch real-time quote for a symbol.
0178:         
0179:         Args:
0180:             symbol: The ticker symbol
0181:             source: Data source to use
0182:             
0183:         Returns:
0184:             MarketQuote object containing latest price data
0185:             
0186:         Raises:
0187:             MarketDataError: If quote cannot be fetched
0188:         """
0189:         cache_key = f"quote:{source}:{symbol}"
0190:         cached_quote = self.cache.get(cache_key)
0191:         if cached_quote:
0192:             return cached_quote
0193:         
0194:         try:
0195:             if source == "yahoo":
0196:                 await self.rate_limiters[source].acquire_async()
0197:                 quote = await self._fetch_yahoo_quote(symbol)
0198:             elif source == "alpha_vantage":
0199:                 await self.rate_limiters[source].acquire_async()
0200:                 quote = await self._fetch_alpha_vantage_quote(symbol)
0201:             else:
0202:                 raise ValueError(f"Unsupported data source: {source}")
0203:             
0204:             self.cache.set(cache_key, quote, ttl=timedelta(seconds=30))
0205:             return quote
0206:         
0207:         except Exception as e:
0208:             logger.error(f"Failed to fetch quote for {symbol} from {source}: {str(e)}")
0209:             raise MarketDataError(f"Quote fetch failed: {str(e)}")
0210:     
0211:     async def get_option_chain(self, symbol: str) -> Dict[str, List[OptionQuote]]:
0212:         """
0213:         Fetch complete option chain for a symbol.
0214:         
0215:         Returns a dictionary mapping expiration dates to lists of option quotes.
0216:         Includes both calls and puts.
0217:         
0218:         Args:
0219:             symbol: The underlying symbol
0220:             
0221:         Returns:
0222:             Dictionary mapping expiry dates to lists of option quotes
0223:         """
0224:         cache_key = f"options:{symbol}"
0225:         cached_chain = self.cache.get(cache_key)
0226:         if cached_chain:
0227:             return cached_chain
0228:         
0229:         try:
0230:             # Fetch using yfinance in thread pool to avoid blocking
0231:             def fetch_chain():
0232:                 ticker = yf.Ticker(symbol)
0233:                 expirations = ticker.options
0234:                 
0235:                 chain = {}
0236:                 for expiry in expirations:
0237:                     opts = ticker.option_chain(expiry)
0238:                     chain[expiry] = []
0239:                     
0240:                     # Process calls
0241:                     for _, row in opts.calls.iterrows():
0242:                         chain[expiry].append(OptionQuote(
0243:                             symbol=symbol,
0244:                             timestamp=datetime.now(),
0245:                             bid=row.bid,
0246:                             ask=row.ask,
0247:                             last=row.lastPrice,
0248:                             volume=row.volume,
0249:                             source="yahoo",
0250:                             strike=row.strike,
0251:                             expiry=datetime.strptime(expiry, "%Y-%m-%d"),
0252:                             option_type="call",
0253:                             underlying_price=ticker.info['regularMarketPrice'],
0254:                             implied_volatility=row.impliedVolatility,
0255:                             open_interest=row.openInterest,
0256:                             delta=row.get('delta'),
0257:                             gamma=row.get('gamma'),
0258:                             theta=row.get('theta'),
0259:                             vega=row.get('vega'),
0260:                             rho=row.get('rho')
0261:                         ))
0262:                     
0263:                     # Process puts
0264:                     for _, row in opts.puts.iterrows():
0265:                         chain[expiry].append(OptionQuote(
0266:                             symbol=symbol,
0267:                             timestamp=datetime.now(),
0268:                             bid=row.bid,
0269:                             ask=row.ask,
0270:                             last=row.lastPrice,
0271:                             volume=row.volume,
0272:                             source="yahoo",
0273:                             strike=row.strike,
0274:                             expiry=datetime.strptime(expiry, "%Y-%m-%d"),
0275:                             option_type="put",
0276:                             underlying_price=ticker.info['regularMarketPrice'],
0277:                             implied_volatility=row.impliedVolatility,
0278:                             open_interest=row.openInterest,
0279:                             delta=row.get('delta'),
0280:                             gamma=row.get('gamma'),
0281:                             theta=row.get('theta'),
0282:                             vega=row.get('vega'),
0283:                             rho=row.get('rho')
0284:                         ))
0285:                 
0286:                 return chain
0287:             
0288:             # Execute in thread pool
0289:             loop = asyncio.get_event_loop()
0290:             chain = await loop.run_in_executor(self._executor, fetch_chain)
0291:             
0292:             # Cache for 5 minutes
0293:             self.cache.set(cache_key, chain, ttl=timedelta(minutes=5))
0294:             return chain
0295:             
0296:         except Exception as e:
0297:             logger.error(f"Failed to fetch option chain for {symbol}: {str(e)}")
0298:             raise MarketDataError(f"Option chain fetch failed: {str(e)}")
0299:     
0300:     async def get_historical_data(self, symbol: str, start_date: datetime,
0301:                                 end_date: datetime, interval: str = "1d") -> pd.DataFrame:
0302:         """
0303:         Fetch historical price data for a symbol.
0304:         
0305:         Args:
0306:             symbol: The ticker symbol
0307:             start_date: Start date for historical data
0308:             end_date: End date for historical data
0309:             interval: Data interval (1d, 1h, etc.)
0310:             
0311:         Returns:
0312:             DataFrame containing historical price data
0313:         """
0314:         cache_key = f"history:{symbol}:{start_date}:{end_date}:{interval}"
0315:         cached_data = self.cache.get(cache_key)
0316:         if cached_data is not None:
0317:             return cached_data
0318:         
0319:         try:
0320:             def fetch_history():
0321:                 ticker = yf.Ticker(symbol)
0322:                 df = ticker.history(
0323:                     start=start_date,
0324:                     end=end_date,
0325:                     interval=interval
0326:                 )
0327:                 return df
0328:             
0329:             # Execute in thread pool
0330:             loop = asyncio.get_event_loop()
0331:             data = await loop.run_in_executor(self._executor, fetch_history)
0332:             
0333:             # Cache for 1 hour if historical data
0334:             if interval != "1m":
0335:                 self.cache.set(cache_key, data, ttl=timedelta(hours=1))
0336:             
0337:             return data
0338:             
0339:         except Exception as e:
0340:             logger.error(f"Failed to fetch historical data for {symbol}: {str(e)}")
0341:             raise MarketDataError(f"Historical data fetch failed: {str(e)}")
0342:     
0343:     async def _fetch_yahoo_quote(self, symbol: str) -> MarketQuote:
0344:         """Internal method to fetch quote from Yahoo Finance."""
0345:         async with self._get_session() as session:
0346:             url = f"https://query1.finance.yahoo.com/v8/finance/chart/{symbol}"
0347:             async with session.get(url) as response:
0348:                 data = await response.json()
0349:                 
0350:                 meta = data['chart']['result'][0]['meta']
0351:                 return MarketQuote(
0352:                     symbol=symbol,
0353:                     timestamp=datetime.fromtimestamp(meta['regularMarketTime']),
0354:                     bid=meta.get('bid', 0.0),
0355:                     ask=meta.get('ask', 0.0),
0356:                     last=meta['regularMarketPrice'],
0357:                     volume=meta['regularMarketVolume'],
0358:                     source="yahoo"
0359:                 )
0360:     
0361:     async def _fetch_alpha_vantage_quote(self, symbol: str) -> MarketQuote:
0362:         """Internal method to fetch quote from Alpha Vantage."""
0363:         api_key = self.config.get("alpha_vantage_api_key")
0364:         if not api_key:
0365:             raise ValueError("Alpha Vantage API key not configured")
0366:         
0367:         async with self._get_session() as session:
0368:             url = f"https://www.alphavantage.co/query"
0369:             params = {
0370:                 "function": "GLOBAL_QUOTE",
0371:                 "symbol": symbol,
0372:                 "apikey": api_key
0373:             }
0374:             
0375:             async with session.get(url, params=params) as response:
0376:                 data = await response.json()
0377:                 quote = data['Global Quote']
0378:                 
0379:                 return MarketQuote(
0380:                     symbol=symbol,
0381:                     timestamp=datetime.now(),  # AV doesn't provide timestamp
0382:                     bid=float(quote.get('09. price', 0.0)),  # No bid/ask provided
0383:                     ask=float(quote.get('09. price', 0.0)),
0384:                     last=float(quote['05. price']),
0385:                     volume=int(quote['06. volume']),
0386:                     source="alpha_vantage"
0387:                 )
0388: 
0389: class MarketDataError(Exception):
0390:     """Custom exception for market data related errors."""
0391:     pass
0392: 
0393: class MarketDataStream:
0394:     """
0395:     Real-time market data streaming client.
0396:     
0397:     This class handles websocket connections for streaming real-time
0398:     market data updates.
0399:     """
0400:     
0401:     def __init__(self, symbols: List[str], callback: callable):
0402:         """
0403:         Initialize streaming client.
0404:         
0405:         Args:
0406:             symbols: List of symbols to stream
0407:             callback: Callback function for data updates
0408:         """
0409:         self.symbols = symbols
0410:         self.callback = callback
0411:         self._ws = None
0412:         self._running = False
0413:         self._reconnect_delay = 1.0  # Initial reconnect delay
0414:         self._max_reconnect_delay = 60.0
0415:     
0416:     async def start(self):
0417:         """Start streaming market data."""
0418:         self._running = True
0419:         while self._running:
0420:             try:
0421:                 await self._connect()
0422:                 await self._stream()
0423:             except Exception as e:
0424:                 logger.error(f"Streaming error: {str(e)}")
0425:                 if self._running:
0426:                     await asyncio.sleep(self._reconnect_delay)
0427:                     self._reconnect_delay = min(
0428:                         self._reconnect_delay * 2,
0429:                         self._max_reconnect_delay
0430:                     )
0431:     
0432:     async def stop(self):
0433:         """Stop streaming market data."""
0434:         self._running = False
0435:         if self._ws:
0436:             await self._ws.close()
0437:     
0438:     async def _connect(self):
0439:         """Establish websocket connection."""
0440:         session = aiohttp.ClientSession()
0441:         self._ws = await session.ws_connect(
0442:             'wss://streamer.finance.yahoo.com',
0443:             heartbeat=30
0444:         )
0445:         
0446:         # Subscribe to symbols
0447:         subscribe_msg = {
0448:             "subscribe": self.symbols
0449:         }
0450:         await self._ws.send_json(subscribe_msg)
0451:         self._reconnect_delay = 1.0  # Reset reconnect delay on successful connection
0452:     
0453:     async def _stream(self):
0454:         """Handle streaming data."""
0455:         async for msg in self._ws:
0456:             if msg.type == aiohttp.WSMsgType.TEXT:
0457:                 data = json.loads(msg.data)
0458:                 await self.callback(data)
0459:             elif msg.type == aiohttp.WSMsgType.CLOSED:
0460:                 break
0461:             elif msg.type == aiohttp.WSMsgType.ERROR:
0462:                 break
0463: 
0464: def format_market_data(quotes: Union[MarketQuote, List[MarketQuote]]) -> pd.DataFrame:
0465:     """
0466:     Format market data quotes into a pandas DataFrame.
0467:     
0468:     Args:
0469:         quotes: Single quote or list of quotes
0470:         
0471:     Returns:
0472:         DataFrame containing formatted market data
0473:     """
0474:     if isinstance(quotes, MarketQuote):
0475:         quotes = [quotes]
0476:     
0477:     data = []
0478:     for quote in quotes:
0479:         row = {
0480:             'symbol': quote.symbol,
0481:             'timestamp': quote.timestamp,
0482:             'bid': quote.bid,
0483:             'ask': quote.ask,
0484:             'last': quote.last,
0485:             'mid': quote.mid,
0486:             'spread': quote.spread,
0487:             'volume': quote.volume,
0488:             'source': quote.source
0489:         }
0490:         
0491:         # Add option-specific fields if available
0492:         if isinstance(quote, OptionQuote):
0493:             row.update({
0494:                 'strike': quote.strike,
0495:                 'expiry': quote.expiry,
0496:                 'option_type': quote.option_type,
0497:                 'underlying_price': quote.underlying_price,
0498:                 'implied_volatility': quote.implied_volatility,
0499:                 'open_interest': quote.open_interest,
0500:                 'delta': quote.delta,
0501:                 'gamma': quote.gamma,
0502:                 'theta': quote.theta,
0503:                 'vega': quote.vega,
0504:                 'rho': quote.rho
0505:             })
0506:         
0507:         data.append(row)
0508:     
0509:     return pd.DataFrame(data)

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\utils\optimization.py
// ----------------------------------------
0001: # src/utils/optimization.py
0002: from typing import Callable, Tuple
0003: import numpy as np
0004: from src.config import AppConfig
0005: 
0006: def newton_raphson(f: Callable, fprime: Callable, x0: float, 
0007:                   tol: float = AppConfig.epsilon, 
0008:                   max_iter: int = AppConfig.max_iterations) -> Tuple[float, bool]:
0009:     """
0010:     Implementation of Newton-Raphson method for root finding.
0011:     
0012:     Args:
0013:         f: Function for which we want to find the root
0014:         fprime: Derivative of f
0015:         x0: Initial guess
0016:         tol: Tolerance for convergence
0017:         max_iter: Maximum number of iterations
0018:     
0019:     Returns:
0020:         Tuple containing the root and a boolean indicating convergence
0021:     """
0022:     x = x0
0023:     for _ in range(max_iter):
0024:         fx = f(x)
0025:         if abs(fx) < tol:
0026:             return x, True
0027:         
0028:         fpx = fprime(x)
0029:         if abs(fpx) < tol:
0030:             return x, False
0031:         
0032:         x = x - fx/fpx
0033:     
0034:     return x, False
0035: 
0036: # src/utils/decorators.py
0037: from functools import lru_cache, wraps
0038: import time
0039: from typing import Any, Callable
0040: 
0041: def timer(func: Callable) -> Callable:
0042:     """Decorator to measure function execution time."""
0043:     @wraps(func)
0044:     def wrapper(*args, **kwargs) -> Any:
0045:         start_time = time.perf_counter()
0046:         result = func(*args, **kwargs)
0047:         end_time = time.perf_counter()
0048:         print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
0049:         return result
0050:     return wrapper
0051: 
0052: def memoize(func: Callable) -> Callable:
0053:     """Enhanced memoization decorator with timeout."""
0054:     cache = {}
0055:     
0056:     @wraps(func)
0057:     def wrapper(*args, **kwargs) -> Any:
0058:         key = str(args) + str(kwargs)
0059:         current_time = time.time()
0060:         
0061:         if key in cache:
0062:             result, timestamp = cache[key]
0063:             if current_time - timestamp < AppConfig.cache_timeout:
0064:                 return result
0065:         
0066:         result = func(*args, **kwargs)
0067:         cache[key] = (result, current_time)
0068:         return result
0069:     
0070:     return wrapper

// File: C:\Users\aluja\Desktop\OptionVisualizer\src\utils\validators.py
// ----------------------------------------
0001: """
0002: Input validation and business rule checking utilities.
0003: 
0004: This module provides:
0005: 1. Type validation and conversion
0006: 2. Business rule validation
0007: 3. Data format validation
0008: 4. Portfolio consistency checks
0009: 5. Custom validation decorators
0010: """
0011: 
0012: import re
0013: from datetime import datetime, date
0014: from typing import Any, Dict, List, Optional, Union, Callable
0015: from decimal import Decimal
0016: from functools import wraps
0017: import pandas as pd
0018: import numpy as np
0019: 
0020: class ValidationError(Exception):
0021:     """Custom exception for validation errors."""
0022:     pass
0023: 
0024: def validate_type(value: Any, expected_type: Union[type, tuple], 
0025:                  field_name: str) -> None:
0026:     """
0027:     Validate that a value is of the expected type.
0028:     
0029:     Args:
0030:         value: Value to validate
0031:         expected_type: Expected type or tuple of types
0032:         field_name: Name of field for error messages
0033:         
0034:     Raises:
0035:         ValidationError: If validation fails
0036:     """
0037:     if not isinstance(value, expected_type):
0038:         raise ValidationError(
0039:             f"{field_name} must be of type {expected_type.__name__}, "
0040:             f"got {type(value).__name__}"
0041:         )
0042: 
0043: def validate_numeric(value: Any, field_name: str,
0044:                     min_value: Optional[float] = None,
0045:                     max_value: Optional[float] = None,
0046:                     allow_zero: bool = True,
0047:                     allow_negative: bool = False) -> float:
0048:     """
0049:     Validate and convert numeric input.
0050:     
0051:     Args:
0052:         value: Value to validate
0053:         field_name: Field name for error messages
0054:         min_value: Optional minimum value
0055:         max_value: Optional maximum value
0056:         allow_zero: Whether to allow zero
0057:         allow_negative: Whether to allow negative values
0058:         
0059:     Returns:
0060:         Validated float value
0061:         
0062:     Raises:
0063:         ValidationError: If validation fails
0064:     """
0065:     try:
0066:         if isinstance(value, str):
0067:             # Remove any currency symbols or commas
0068:             value = value.replace(', ').replace(',', '').strip()
0069:         
0070:         # Convert to float
0071:         num_value = float(value)
0072:         
0073:         # Validate constraints
0074:         if not allow_zero and num_value == 0:
0075:             raise ValidationError(f"{field_name} cannot be zero")
0076:         
0077:         if not allow_negative and num_value < 0:
0078:             raise ValidationError(f"{field_name} cannot be negative")
0079:         
0080:         if min_value is not None and num_value < min_value:
0081:             raise ValidationError(
0082:                 f"{field_name} must be greater than or equal to {min_value}"
0083:             )
0084:         
0085:         if max_value is not None and num_value > max_value:
0086:             raise ValidationError(
0087:                 f"{field_name} must be less than or equal to {max_value}"
0088:             )
0089:         
0090:         return num_value
0091:     
0092:     except (TypeError, ValueError) as e:
0093:         raise ValidationError(f"{field_name} must be a valid number")
0094: 
0095: def validate_date(value: Any, field_name: str,
0096:                  min_date: Optional[date] = None,
0097:                  max_date: Optional[date] = None) -> date:
0098:     """
0099:     Validate and convert date input.
0100:     
0101:     Args:
0102:         value: Date value to validate (string, datetime, or date)
0103:         field_name: Field name for error messages
0104:         min_date: Optional minimum allowed date
0105:         max_date: Optional maximum allowed date
0106:         
0107:     Returns:
0108:         Validated date object
0109:     """
0110:     try:
0111:         if isinstance(value, datetime):
0112:             dt = value.date()
0113:         elif isinstance(value, date):
0114:             dt = value
0115:         elif isinstance(value, str):
0116:             # Try common date formats
0117:             for fmt in ('%Y-%m-%d', '%m/%d/%Y', '%d/%m/%Y', '%Y%m%d'):
0118:                 try:
0119:                     dt = datetime.strptime(value, fmt).date()
0120:                     break
0121:                 except ValueError:
0122:                     continue
0123:             else:
0124:                 raise ValidationError(f"{field_name} is not in a recognized date format")
0125:         else:
0126:             raise ValidationError(f"{field_name} must be a valid date")
0127:         
0128:         # Validate range
0129:         if min_date and dt < min_date:
0130:             raise ValidationError(
0131:                 f"{field_name} must be on or after {min_date.strftime('%Y-%m-%d')}"
0132:             )
0133:         
0134:         if max_date and dt > max_date:
0135:             raise ValidationError(
0136:                 f"{field_name} must be on or before {max_date.strftime('%Y-%m-%d')}"
0137:             )
0138:         
0139:         return dt
0140:     
0141:     except (TypeError, ValueError) as e:
0142:         raise ValidationError(f"{field_name} must be a valid date")
0143: 
0144: def validate_option_parameters(func: Callable) -> Callable:
0145:     """
0146:     Decorator to validate option pricing parameters.
0147:     
0148:     Validates:
0149:     - Strike price > 0
0150:     - Time to expiry >= 0
0151:     - Volatility > 0
0152:     - Interest rate is reasonable
0153:     """
0154:     @wraps(func)
0155:     def wrapper(*args, **kwargs):
0156:         # Extract parameters from args/kwargs
0157:         params = {}
0158:         sig = inspect.signature(func)
0159:         bound_args = sig.bind(*args, **kwargs)
0160:         bound_args.apply_defaults()
0161:         params.update(bound_args.arguments)
0162:         
0163:         # Validate strike price
0164:         validate_numeric(
0165:             params.get('strike', 0),
0166:             'Strike price',
0167:             min_value=0.01,
0168:             allow_zero=False
0169:         )
0170:         
0171:         # Validate time to expiry
0172:         validate_numeric(
0173:             params.get('time_to_expiry', 0),
0174:             'Time to expiry',
0175:             min_value=0,
0176:             allow_negative=False
0177:         )
0178:         
0179:         # Validate volatility
0180:         validate_numeric(
0181:             params.get('volatility', 0),
0182:             'Volatility',
0183:             min_value=0.0001,
0184:             max_value=5.0,
0185:             allow_zero=False
0186:         )
0187:         
0188:         # Validate interest rate
0189:         validate_numeric(
0190:             params.get('interest_rate', 0),
0191:             'Interest rate',
0192:             min_value=-0.1,
0193:             max_value=0.5
0194:         )
0195:         
0196:         return func(*args, **kwargs)
0197:     
0198:     return wrapper
0199: 
0200: def validate_portfolio_position(position: Dict[str, Any]) -> None:
0201:     """
0202:     Validate a portfolio position entry.
0203:     
0204:     Checks:
0205:     - Required fields are present
0206:     - Field types are correct
0207:     - Values are within valid ranges
0208:     - Option parameters are consistent
0209:     """
0210:     required_fields = {
0211:         'symbol': str,
0212:         'quantity': int,
0213:         'position_type': str,
0214:         'strike': float,
0215:         'expiry': (date, datetime),
0216:         'option_type': str
0217:     }
0218:     
0219:     # Check required fields
0220:     for field, field_type in required_fields.items():
0221:         if field not in position:
0222:             raise ValidationError(f"Missing required field: {field}")
0223:         validate_type(position[field], field_type, field)
0224:     
0225:     # Validate quantity
0226:     validate_numeric(
0227:         position['quantity'],
0228:         'Quantity',
0229:         allow_zero=False
0230:     )
0231:     
0232:     # Validate strike price
0233:     validate_numeric(
0234:         position['strike'],
0235:         'Strike price',
0236:         min_value=0.01,
0237:         allow_zero=False
0238:     )
0239:     
0240:     # Validate option type
0241:     if position['option_type'].lower() not in ('call', 'put'):
0242:         raise ValidationError("Option type must be either 'call' or 'put'")
0243:     
0244:     # Validate expiry is in the future
0245:     expiry = position['expiry']
0246:     if isinstance(expiry, datetime):
0247:         expiry = expiry.date()
0248:     if expiry < date.today():
0249:         raise ValidationError("Option expiry cannot be in the past")
0250: 
0251: def validate_portfolio_margin(positions: List[Dict[str, Any]],
0252:                            account_value: float) -> None:
0253:     """
0254:     Validate portfolio margin requirements.
0255:     
0256:     Checks:
0257:     - Portfolio total exposure within limits
0258:     - Individual position sizes appropriate
0259:     - Margin requirements are met
0260:     - Risk metrics within acceptable ranges
0261:     """
0262:     # Calculate total exposure
0263:     total_exposure = sum(
0264:         abs(pos['quantity'] * pos['strike'])
0265:         for pos in positions
0266:     )
0267:     
0268:     # Check against account value
0269:     max_exposure = account_value * 5  # Example: 5x leverage limit
0270:     if total_exposure > max_exposure:
0271:         raise ValidationError(
0272:             f"Total exposure ({total_exposure}) exceeds maximum allowed "
0273:             f"({max_exposure}) for account size"
0274:         )
0275:     
0276:     # Check individual position sizes
0277:     for position in positions:
0278:         position_exposure = abs(position['quantity'] * position['strike'])
0279:         if position_exposure > account_value:
0280:             raise ValidationError(
0281:                 f"Individual position exposure ({position_exposure}) "
0282:                 f"exceeds account value"
0283:             )
0284:     
0285:     # Additional margin checks could be added here
0286:     # This is a simplified example
0287: 
0288: def validate_data_format(df: pd.DataFrame, 
0289:                         expected_columns: List[str],
0290:                         column_types: Optional[Dict[str, type]] = None) -> None:
0291:     """
0292:     Validate DataFrame format and content.
0293:     
0294:     Args:
0295:         df: DataFrame to validate
0296:         expected_columns: List of required columns
0297:         column_types: Optional mapping of column names to expected types
0298:     """
0299:     # Check for required columns
0300:     missing_cols = set(expected_columns) - set(df.columns)
0301:     if missing_cols:
0302:         raise ValidationError(f"Missing required columns: {missing_cols}")
0303:     
0304:     # Validate column types if specified
0305:     if column_types:
0306:         for col, expected_type in column_types.items():
0307:             if col in df.columns:
0308:                 # Check if column can be converted to expected type
0309:                 try:
0310:                     df[col].astype(expected_type)
0311:                 except (ValueError, TypeError):
0312:                     raise ValidationError(
0313:                         f"Column '{col}' cannot be converted to {expected_type.__name__}"
0314:                     )
0315:     
0316:     # Check for empty DataFrame
0317:     if df.empty:
0318:         raise ValidationError("DataFrame cannot be empty")
0319:     
0320:     # Check for missing values in required columns
0321:     missing_values = df[expected_columns].isna().any()
0322:     if missing_values.any():
0323:         cols_with_missing = missing_values[missing_values].index.tolist()
0324:         raise ValidationError(
0325:             f"Missing values found in columns: {cols_with_missing}"
0326:         )
0327: 
0328: def validate_csv_file(file_path: str,
0329:                      expected_columns: List[str],
0330:                      column_types: Optional[Dict[str, type]] = None) -> pd.DataFrame:
0331:     """
0332:     Validate a CSV file before processing.
0333:     
0334:     Args:
0335:         file_path: Path to CSV file
0336:         expected_columns: List of required columns
0337:         column_types: Optional mapping of column names to expected types
0338:         
0339:     Returns:
0340:         Validated DataFrame
0341:     """
0342:     try:
0343:         # Try to read the CSV file
0344:         df = pd.read_csv(file_path)
0345:         
0346:         # Validate format
0347:         validate_data_format(df, expected_columns, column_types)
0348:         
0349:         # Additional CSV-specific checks
0350:         if df.shape[0] > 1000000:  # Example limit
0351:             raise ValidationError("CSV file too large (> 1M rows)")
0352:         
0353:         return df
0354:         
0355:     except pd.errors.EmptyDataError:
0356:         raise ValidationError("CSV file is empty")
0357:     except pd.errors.ParserError:
0358:         raise ValidationError("Invalid CSV format")
0359:     except FileNotFoundError:
0360:         raise ValidationError("CSV file not found")
0361:     except Exception as e:
0362:         raise ValidationError(f"Error reading CSV file: {str(e)}")
0363: 
0364: class DataFrameValidator:
0365:     """
0366:     Validator class for DataFrame operations with custom rules.
0367:     """
0368:     
0369:     def __init__(self, df: pd.DataFrame):
0370:         self.df = df
0371:         self.errors = []
0372:     
0373:     def validate_unique(self, columns: Union[str, List[str]]) -> 'DataFrameValidator':
0374:         """Check if specified columns contain unique values."""
0375:         if isinstance(columns, str):
0376:             columns = [columns]
0377:         
0378:         for col in columns:
0379:             if not self.df[col].is_unique:
0380:                 self.errors.append(f"Column '{col}' contains duplicate values")
0381:         
0382:         return self
0383:     
0384:     def validate_range(self, column: str,
0385:                       min_value: Optional[float] = None,
0386:                       max_value: Optional[float] = None) -> 'DataFrameValidator':
0387:         """Validate numeric values are within specified range."""
0388:         values = self.df[column]
0389:         
0390:         if min_value is not None and values.min() < min_value:
0391:             self.errors.append(
0392:                 f"Column '{column}' contains values below minimum {min_value}"
0393:             )
0394:         
0395:         if max_value is not None and values.max() > max_value:
0396:             self.errors.append(
0397:                 f"Column '{column}' contains values above maximum {max_value}"
0398:             )
0399:         
0400:         return self
0401:     
0402:     def validate_regex(self, column: str, pattern: str) -> 'DataFrameValidator':
0403:         """Validate string values match regex pattern."""
0404:         invalid_values = self.df[~self.df[column].str.match(pattern)]
0405:         if not invalid_values.empty:
0406:             self.errors.append(
0407:                 f"Column '{column}' contains values not matching pattern '{pattern}'"
0408:             )
0409:         
0410:         return self
0411:     
0412:     def raise_if_invalid(self) -> None:
0413:         """Raise ValidationError if any validations failed."""
0414:         if self.errors:
0415:             raise ValidationError("\n".join(self.errors))
0416: 
0417: def validate_parameters(func: Callable) -> Callable:
0418:     """
0419:     Generic parameter validation decorator.
0420:     
0421:     This decorator checks that function parameters meet specified criteria
0422:     using type hints and optional validation rules.
0423:     """
0424:     @wraps(func)
0425:     def wrapper(*args, **kwargs):
0426:         sig = inspect.signature(func)
0427:         bound_args = sig.bind(*args, **kwargs)
0428:         bound_args.apply_defaults()
0429:         
0430:         # Get type hints
0431:         hints = get_type_hints(func)
0432:         
0433:         # Validate each parameter
0434:         for name, value in bound_args.arguments.items():
0435:             if name in hints:
0436:                 expected_type = hints[name]
0437:                 
0438:                 # Handle Optional types
0439:                 if (
0440:                     hasattr(expected_type, '__origin__') and
0441:                     expected_type.__origin__ is Union and
0442:                     type(None) in expected_type.__args__
0443:                 ):
0444:                     if value is not None:
0445:                         expected_type = expected_type.__args__[0]
0446:                     else:
0447:                         continue
0448:                 
0449:                 # Validate type
0450:                 validate_type(value, expected_type, name)
0451:                 
0452:                 # Additional validation based on parameter name
0453:                 if 'price' in name.lower():
0454:                     validate_numeric(value, name, min_value=0)
0455:                 elif 'quantity' in name.lower():
0456:                     validate_numeric(value, name, allow_zero=False)
0457:                 elif 'date' in name.lower():
0458:                     validate_date(value, name)
0459:         
0460:         return func(*args, **kwargs)
0461:     
0462:     return wrapper

// ----------------------------------------
// Total Python files found: 33
